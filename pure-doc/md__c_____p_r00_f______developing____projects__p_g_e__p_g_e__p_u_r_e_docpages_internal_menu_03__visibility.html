<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PURE API: Visibility Optimizations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="pure_doxystyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="still-single-logo.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">PURE API<span id="projectnumber">&#160;0.3</span>
   </div>
   <div id="projectbrief">PR00F&#39;s Ultimate Rendering Engine full documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Visibility Optimizations </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#prepipe">Pre-Pipe Techniques</a><ul><li class="level2"><a href="#structures">Spatial Hierarchies / Acceleration Structures</a><ul><li class="level3"><a href="#pvs">PVS: Potentially Visible Set</a></li>
<li class="level3"><a href="#bsp">BSP: Binary Space Partitioning</a></li>
<li class="level3"><a href="#quadtree">Quadtree</a></li>
<li class="level3"><a href="#octree">Octree</a></li>
<li class="level3"><a href="#bvh">BVH: Bounding Volume Hierarchy</a></li>
<li class="level3"><a href="#portal">Portal</a></li>
<li class="level3"><a href="#antiportal">Antiportal</a></li>
</ul>
</li>
<li class="level2"><a href="#lod">LOD: Level of Detail</a></li>
<li class="level2"><a href="#rendering_distances">Minimum and Maximum Rendering Distance</a></li>
</ul>
</li>
<li class="level1"><a href="#inpipe">In-Pipe Techniques</a><ul><li class="level2"><a href="#vfc">VFC: View Frustum Culling</a><ul><li class="level3"><a href="#hvfc">Hierarchical View Frustum Culling</a></li>
</ul>
</li>
<li class="level2"><a href="#occlusion">Occlusion Culling</a><ul><li class="level3"><a href="#occlusion_pure_related">PURE Specific Info</a></li>
<li class="level3"><a href="#h_occlusion">Hierarchical Occlusion Culling</a></li>
</ul>
</li>
<li class="level2"><a href="#backface">Backface Culling</a></li>
<li class="level2"><a href="#depth_buffering">Depth Buffering</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="visibility"></a></p>
<p >Usually the rendering speed defines the overall speed of a game due to its complexity compared to other parts that also need processing (sounds, input, etc.). <br  />
 There are 2 major ways to increase rendering speed:</p><ul>
<li>do not render objects that would end up not visible in the final image anyway;</li>
<li>reduce quality of rendering without reducing the quality of the final image.</li>
</ul>
<p >There are numerous ways to decide if a 3D object or part of it is visible from the player's point of view or not. <br  />
 <b>There is not a single best way to do it but different methods</b> that are operated at different stages of the rendering pipeline, and should be used together for best performance. <br  />
 We also call these as <b>Hidden Surface Removal</b> techniques or <b>Culling</b>. <br  />
 There are some other simple ways as well like defining maximum rendering distance of an object to the viewer. On this page I'm mentioning all techniques I have read about although not all of them are implemented in PURE engine. This is always explicitly noted.</p>
<p >I'm grouping techniques into 2:</p><ul>
<li>pre-pipe;</li>
<li>in-pipe.</li>
</ul>
<p >Pre-pipe techniques do not need the graphics pipeline to be executed to decide if an object can be ignored for rendering or not. To maximize speed, we want to make use of such techniques as much as we can. <br  />
 In-pipe techniques operate within the graphics pipeline because they need data for their visibility decisions that are produced within the pipeline. Even if an object is sent to the pipeline, it is still better to cull it in an earlier than in a later stage.</p>
<h1><a class="anchor" id="prepipe"></a>
Pre-Pipe Techniques</h1>
<h2><a class="anchor" id="structures"></a>
Spatial Hierarchies / Acceleration Structures</h2>
<p >Following few hierarchies can be used to avoid doing visibility tests on single objects, but instead test against group of objects, for more efficient decision making. <br  />
 They can also provide a recommended order of iterating over objects or polygons. Although these are basically structures, they can be combined with visibility decision maker algorithms such as <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#vfc">VFC: View Frustum Culling</a> for more efficiency.</p>
<h3><a class="anchor" id="pvs"></a>
PVS: Potentially Visible Set</h3>
<p >PURE engine does not use PVS. <br  />
 The scene is divided into cells, and for every single cell, we list all other visible cells from that cell. This is a preprocessing step. During real-time rendering, we just need to decide in which cell the camera is currently in and render only those objects that are in the visible cells. This technique can be used independent of and prior to feeding the graphics pipeline, thus it can save a lot of time because we can skip sending objects to the pipeline. Although this technique requires preprocessing, this can be used in realtime mobile games too. <br  />
</p>
<h3><a class="anchor" id="bsp"></a>
BSP: Binary Space Partitioning</h3>
<p >PURE engine does not use BSP. <br  />
 We recursively divide the scene into two until some requirements are satisfied. For example, we can place polygons left or right in the tree based on if they are in front of or behind a plane, and do this recursively. As a result, we can traverse the tree that gives back-to-front or front-to-back order of polygons from view position, and send them in such order into the rendering pipeline, enabling proper occlusion of polygons even without using a depth buffer! This was actually used in games for the painter's algorithm before depth buffering widespread. <br  />
 Note that BSPs are still used nowadays for different purposes such as helping generating <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#pvs">PVS: Potentially Visible Set</a>.</p>
<h3><a class="anchor" id="quadtree"></a>
Quadtree</h3>
<p >PURE engine does not use Quadtree. <br  />
 We insert scene objects into a tree structure, where each node can have exactly 4 children nodes. Quadtree is the two-dimensional analog of <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#octree">Octree</a> and is most often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions.</p>
<h3><a class="anchor" id="octree"></a>
Octree</h3>
<p >PURE engine does not use Octree. <br  />
 We insert scene objects into a tree structure, where each node can have exactly 8 children nodes. A node is considered as a cubic volume. Its 8 children equally partition it. <br  />
 When we insert a new object in the tree, we do it in a top-down fashion, so we start from the root node and progress down to the leaves. If the current node is a leaf and doesn't contain any object yet, we insert the new object into it. Otherwise if it already contains an object, we split that node into 8 cells and insert both the already contained and the new objects in the proper cells. Note that an object can be placed into multiple cells at the same time if it overlaps multiple cells.</p>
<p ><a class="anchor" id="autotoc_md21"></a> </p><h5>Loose Octree</h5>
<p >PURE engine does not use Loose Octree. <br  />
</p>
<p ><a href="https://sakura7.blog.hu/2010/07/05/loose_octree">https://sakura7.blog.hu/2010/07/05/loose_octree</a> <br  />
 <a href="http://www.tulrich.com/geekstuff/partitioning.html">http://www.tulrich.com/geekstuff/partitioning.html</a></p>
<h3><a class="anchor" id="bvh"></a>
BVH: Bounding Volume Hierarchy</h3>
<p >PURE engine does not support this. <br  />
 The bounding volumes of objects are put in a hierarchical tree. <br  />
 With the help of an octree, we can easily build the hierarchy. <br  />
 First insert the objects into the octree as described earlier. <br  />
 Then we traverse the tree from bottom to top: starting with the leaves, we calculate the bounding boxes of the objects contained by each of the leaves. Then, 1 level above, we calculate the overall bounding volumes for the node grouping all its children together. We recursively progressing up towards the root node, where the biggest bounding volume containing all previously calculated bounding volumes is created. <br  />
 With the help of such spatial hierarchy, a lot of operations such as ray intersection tests will take much less time, since we start the tests with the root node, and continue the testing with children bounding volumes only if the test passed.</p>
<p ><a href="https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/bounding-volume-hierarchy-BVH-part2">https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/bounding-volume-hierarchy-BVH-part2</a> <br  />
 <a href="https://github.com/LeoGuo98/csc418-A4-bounding-volume-hierarchy">https://github.com/LeoGuo98/csc418-A4-bounding-volume-hierarchy</a> <br  />
 <a href="https://github.com/brandonpelfrey/Fast-BVH">https://github.com/brandonpelfrey/Fast-BVH</a> <br  />
 <a href="https://github.com/leonardo-domingues/atrbvh">https://github.com/leonardo-domingues/atrbvh</a> <br  />
 <a href="https://github.com/taqu/BoundingVolumeHierarchy">https://github.com/taqu/BoundingVolumeHierarchy</a> <br  />
 <a href="https://github.com/mirkoalicastro/bounding-volume-hierarchy">https://github.com/mirkoalicastro/bounding-volume-hierarchy</a> <br  />
 <a href="https://github.com/GrandPiaf/Raytracer">https://github.com/GrandPiaf/Raytracer</a></p>
<h3><a class="anchor" id="portal"></a>
Portal</h3>
<p >PURE engine does not use portals. <br  />
 Portal is a surface that connects 2 adjacent 3D spaces that are visible from each other through this surface, e.g. a door connecting 2 rooms. So a portal is the inverse of an occluder because it tells which polygons/objects are definitely visible behind it! Suitable for indoor maps only and needs preprocessing for identifying portals or level designer needs to mark portals.</p>
<h3><a class="anchor" id="antiportal"></a>
Antiportal</h3>
<p >PURE engine does not use antiportals. <br  />
 The inverse of a portal. A surface that is technically an occluder, with a shape of a rectangle. This rectangle is considered as the "near plane" of a view frustum, and objects falling into this frustum can be culled. <br  />
 Needs no or less preprocessing compared to portals. Can be used in both in- and outdoor maps. Needs already existing <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#structures">Spatial Hierarchies / Acceleration Structures</a> though to be efficient.</p>
<h2><a class="anchor" id="lod"></a>
LOD: Level of Detail</h2>
<p >PURE engine does not support this. <br  />
 This is not about culling the object but to reduce its processing time without causing any image quality degradation. <br  />
 If an object consists of thousand of polygons but is far from the viewer, there is not much use of rendering such complex geometry that would finally end up as just a few pixels due to its distance from the camera. Still we need to render something because the object is visible for sure. In such cases it is reasonable to render a lower level of geometry, which won't cause any noticeable difference in the rendered image. There can be multiple levels of detail of an object, where the first level is the original geometry with 10000 vertices, the second level is a reduced complexity level with 3000 vertices, and so on, and the LOD level is chosen automatically based on the object's distance to the viewer. <br  />
 There are other methods such as dynamic level of detail for terrain, where no precalculated reduced level of geometry is stored.</p>
<h2><a class="anchor" id="rendering_distances"></a>
Minimum and Maximum Rendering Distance</h2>
<p >PURE engine does not support this. <br  />
 Sometimes it is reasonable to define minimum and/or maximum rendering distance for specific objects, e.g. tiny pickupable items, that are not needed to be rendered if they are too far from the viewer. Note that this is not related to camera's near and far clipping plane settings!</p>
<h1><a class="anchor" id="inpipe"></a>
In-Pipe Techniques</h1>
<h2><a class="anchor" id="vfc"></a>
VFC: View Frustum Culling</h2>
<p >PURE engine does not support this. <br  />
 This is done in Clip Space of the <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_02__architecture.html#geometry_stage">Geometry Stage</a> of the graphics pipeline. <br  />
 Although low-level HW rendering APIs such as OpenGL implement clipping planes and automatically do the primitive clipping or culling for us in Clip Space, there are still disadvantages of just relying on this simple way of culling:</p><ul>
<li>with many objects in the scene, many objects are needed to be transformed into Clip Space one-by-one to decide if they can be culled away;</li>
<li>this also means many objects are needed to be checked against the clipping planes.</li>
</ul>
<p >To speed things up, we can use the bounding box of such object instead of its full geometry and test that against the clipping planes. If the bounding box is completely outside the view frustum we can cull the object thus we could win some time by not transforming its complex geometry from model-space to clip-space. More on this in <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_02__architecture.html#architecture">architecture</a>. <br  />
 With this approach, we manage to save on transforming complex geometries, because we just transform their bounding boxes to decide if we should cull them. But still, does this bring actual speedup? With modern GPUs the bottleneck is usually NOT the transformation of complex geometries but rasterizing them. This depends on how complex shading programs are bound to them. Also, stalling the rendering pipeline by introducing the check on CPU side if the bounding box is within the view frustum or not brings in slowdown.</p>
<p ><a href="http://www.lighthouse3d.com/tutorials/view-frustum-culling/">http://www.lighthouse3d.com/tutorials/view-frustum-culling/</a> <br  />
 <a href="https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/frustum-culling-r4613/">https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/frustum-culling-r4613/</a> <br  />
 <a href="https://bruop.github.io/frustum_culling/">https://bruop.github.io/frustum_culling/</a> <br  />
 <a href="http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf">http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf</a> <br  />
 <a href="https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/">https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/</a> <br  />
 <a href="https://www.researchgate.net/publication/2803988_Optimized_View_Frustum_Culling_Algorithms_for_Bounding_Boxes">https://www.researchgate.net/publication/2803988_Optimized_View_Frustum_Culling_Algorithms_for_Bounding_Boxes</a> <br  />
</p>
<h3><a class="anchor" id="hvfc"></a>
Hierarchical View Frustum Culling</h3>
<p >PURE engine does not support this. <br  />
 Same as VFC but 3D objects are organized into some kind of <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#structures">Spatial Hierarchies / Acceleration Structures</a> such as <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#bvh">BVH: Bounding Volume Hierarchy</a>. This way we check if bigger bounding volumes are in the view frustum - if not then all objects within that bounding volume can be easily culled without further testing. This reduces the number of bounding box tests even with many objects. Less testing leads to more speed.</p>
<h2><a class="anchor" id="occlusion"></a>
Occlusion Culling</h2>
<p >PURE engine supports HW occlusion culling. <br  />
 Summary: we can decide if an object is occluded by another object or not. If so, we can skip rendering it. <br  />
 Although I put this method after VFC since this needs later stage of the rendering pipeline as well to operate (i.e. depth-testing of an object bounding box), it is not necessarily worse than VFC. It can actually replace VFC, and if implemented in a sophisticated way such as CHC, it can also outperform it. For CHC, and details of Occlusion Culling, a specific page is maintained: <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03_01__occlusion__culling.html#occlusion_culling">occlusion_culling</a>.</p>
<h3><a class="anchor" id="occlusion_pure_related"></a>
PURE Specific Info</h3>
<p >By default occlusion culling is enabled by PURE. <br  />
 Occluders and occludees are automatically selected, the user doesn't have to add any extra code to client application. <br  />
 Currently the most important factor in deciding if an object is an occluder or occludee is its PRREObject3D::getBiggestAreaScaled(), compared to the average biggest area of all objects. <b>Some sample calculations with different methods can be checked in <a href="PURE-occluder-selection.xlsx" target="_blank">PURE-occluder-selection.xlsx.</a></b></p>
<p >Not all occludees are tested for occlusion. There is a hidden function PRREObject3DManager::PRREObject3DManagerImpl::isEligibleForOcclusionQuery() that decides if occlusion query will be generated for an object or not. <br  />
 Public functions related to this occluder-occludee-occlusion topic are below, some can control the automatic occluder/occludee selection:</p><ul>
<li>PRREObject3D::isOccluder()</li>
<li>PRREObject3D::SetOccluder()</li>
<li>PRREObject3D::isOccluded()</li>
<li>PRREObject3D::isOcclusionTested()</li>
<li>PRREObject3D::SetOcclusionTested()</li>
<li>PRREObject3D::getBoundingBoxObject()</li>
<li>PRREObject3D::ForceFinishOcclusionTest()</li>
<li>PRREObject3DManager::UpdateOccluderStates()</li>
<li>PRREObject3DManager::getOccluderSelectionBias()</li>
<li>PRREObject3DManager::SetOccluderSelectionBias()</li>
<li>PRREObject3DManager::getMaxOccluderCount()</li>
<li>PRREObject3DManager::SetMaxOccluderCount()</li>
</ul>
<h3><a class="anchor" id="h_occlusion"></a>
Hierarchical Occlusion Culling</h3>
<p >PURE does not support hierarchical HW occlusion culling. <br  />
 Same as occlusion culling but as like as <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#hvfc">Hierarchical View Frustum Culling</a>, we take advantage of organizing 3D objects into <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03__visibility.html#structures">Spatial Hierarchies / Acceleration Structures</a>, so we might be able to do less occlusion testing by starting initial occlusion queries for the bigger spatial groups such as bounding volumes first. <br  />
 Note that details are not described here but on the own page of <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_03_01__occlusion__culling.html#occlusion_culling">occlusion_culling</a>.</p>
<h2><a class="anchor" id="backface"></a>
Backface Culling</h2>
<p >PURE relies on HW Backface Culling. <br  />
 A primitive can be discarded based on its facing. More on this in <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_02__architecture.html#architecture">architecture</a>. <br  />
 This is done in the <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_02__architecture.html#raster_stage">Rasterization / Rendering Stage</a> which is pretty late in the pipeline, so culling an object at this point can save fill rate only.</p>
<h2><a class="anchor" id="depth_buffering"></a>
Depth Buffering</h2>
<p >PURE relies on HW Depth Buffering. <br  />
 This is not specifically for optimizing rendering speed but to decide if a pixel should be written to the frame buffer or not. <br  />
 Happens at the very end of the rendering pipeline thus not much speed can be gained with it. <br  />
 More on this in <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_02__architecture.html#architecture">architecture</a>.</p>
<p >Note that PURE renders <b>opaque objects front-to-back</b> which brings rendering speedup by 2 ways:</p><ul>
<li><b>reduce overdraw</b>: try to write only those colors to frame buffer that actually end up visible in the final image, since rendering objects closer to camera first leads to far more depth test fails during rendering objects farther to camera;</li>
<li>effectively utilising <b>Early Depth Testing</b> since rendering objects closer to camera first leads to far more fragment processing skip due to more depth test fails during rendering objects farther to camera. You can read about this ordering as <b>Depth Sorting</b> in the <a class="el" href="md__c_____p_r00_f______developing____projects__p_g_e__p_g_e__p_u_r_e_docpages_internal_menu_06__glossary.html#glossary">glossary</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Aug 5 2024 13:01:37 for PURE API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
