<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PURE API: Occlusion Culling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="pure_doxystyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="still-single-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PURE API
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">PR00F&#39;s Ultimate Rendering Engine full documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('occlusion_culling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Occlusion Culling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occlusion_basics">Basics of Occlusion Culling</a><ul><li class="level2"><a href="#should_not_be_occludee">What Should Not Be an Occludee</a></li>
<li class="level2"><a href="#occlusion_stalling">Stalling the Pipeline with Synchronization</a></li>
<li class="level2"><a href="#occlusion_temporal_coherence">Solving Stalls by Exploiting Temporal Coherence</a></li>
<li class="level2"><a href="#occlusion_simple_pseudocode">Simple Pseudo-code</a></li>
</ul>
</li>
<li class="level1"><a href="#chc">CHC: Coherent Hierarchical Culling</a></li>
<li class="level1"><a href="#chcpp">CHC++: Enhanced Coherent Hierarchical Culling</a></li>
<li class="level1"><a href="#occlusion_materials">Materials to Read</a></li>
<li class="level1"><a href="#occlusion_extensions">OpenGL Extensions for HW Occlusion Culling Support</a><ul><li class="level2"><a href="#GL_HP_occlusion_test">GL_HP_occlusion_test</a></li>
<li class="level2"><a href="#GL_HP_visibility_test">GL_HP_visibility_test</a></li>
<li class="level2"><a href="#GL_HP_visibility_stats">GL_HP_visibility_stats</a></li>
<li class="level2"><a href="#GL_NV_occlusion_query">GL_NV_occlusion_query</a></li>
<li class="level2"><a href="#GL_NV_occlusion_query_samples">GL_NV_occlusion_query_samples</a></li>
<li class="level2"><a href="#GL_ARB_occlusion_query">GL_ARB_occlusion_query</a></li>
<li class="level2"><a href="#GL_ARB_occlusion_query2">GL_ARB_occlusion_query2</a></li>
<li class="level2"><a href="#GL_EXT_occlusion_query_boolean">GL_EXT_occlusion_query_boolean</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occlusion_basics"></a>
Basics of Occlusion Culling</h1>
<p>Idea of occlusion culling is that we separate objects into 2 groups: occluders and occludees. <br  />
 <b>Occluders</b> are usually the big static objects like buildings in a map, we render them first so their depth data is written into the depth buffer first. <br  />
 <b>Occludees</b> are usually smaller, but may be even more complex objects that might be occluded by occluders. <br  />
 We do occlusion tests for each of the bounding box of the occludees, and see if we need to actually render any occludees.</p>
<p>Overall this can save some time, provided that: <br  />
</p><ul>
<li>the occludee geometry is reasonably more complex than its bounding box geometry and we have bottleneck in the geometry stage, or</li>
<li>if the fragment shaders that would normally had been executed for the occludee object in the rasterization stage would be more expensive than the rasterization of the bounding box itself.</li>
</ul>
<p>"For the cost of rendering a bounding box, you can potentially save rendering a normal object. A bounding box consists of only 12 triangles, whereas the original object might have contained
thousands or even millions of triangles." (<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt">https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt</a>) <br  />
</p>
<p><b>Example scene from PR00FPS with enabled occlusion culling where red bounding boxes represent occluded state of snails and other items above the player:</b> <br  />
 the ground level of the map occludes the objects represented by their red bounding boxes, so rendering of these objects can be skipped. In this particular example, <b>only 5664 triangles</b> were needed to be rendered in the frame when this picture was taken, compared to the <b>9076 triangles</b> that otherwise would had been needed to be rendered without the use of occlusion culling method. <img src="PR00FPS_occlusion_culling.jpg" alt="" class="inline"/>   </p>
<h2><a class="anchor" id="should_not_be_occludee"></a>
What Should Not Be an Occludee</h2>
<p>"Because we can see through translucent objects (and they cannot be written to the depth buffer!), these can act only as occludees and not occluders. <br  />
 On the other hand, opaque objects can be both occluders and occludees, which means that they should be sorted from front to back and rendered before translucent objects. After that, translucent objects are sorted back to front and rendered on-screen as well." <br  />
 (<a href="https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling">https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling</a>)</p>
<p>"Using bounding box occlusion queries may either help or hurt in fill-limited situations, because rendering the pixels of a bounding box is not free. In most situations, a bounding box will probably have more pixels than the original object. Those pixels can probably be rendered more quickly, though, since they involve only Z reads (no Z writes or color traffic), and they need not be textured or otherwise shaded." <br  />
 (<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt">https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt</a>)</p>
<p>"When only depth testing or stencil writing is taking place, some new GPUs (such as the GeForce FX family) use a higher-performance rendering path. <br  />
 In the past, hardware didn't benefit much when the color buffer was switched off during testing for the visibility of a bounding box, because the circuits for color and depth value output were in the same pipeline. Now, however, on newer hardware, if the color-buffer output is switched off, the pipelines are used for depth testing and the bounding box testing is faster." <br  />
 (<a href="https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling">https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling</a>)</p>
<p>"The fill-rate problem can get even worse, because sometimes a bounding box needs to be rendered from both sides, with front-facing and back-facing polygons! The catch is that when you test an object that is very close to the view origin, the viewer ends up inside the bounding box. That's why we need to render back faces also; otherwise, because of back-face culling, no pixels will be drawn on-screen, and we'll get a false result. To be safe, skip occlusion testing for models that are too near the viewer; it can really do more harm than good, and an object that close is definitely visible." <br  />
 (<a href="https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling">https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling</a>)</p>
<h2><a class="anchor" id="occlusion_stalling"></a>
Stalling the Pipeline with Synchronization</h2>
<p>Note that since we are already in the rendering pipeline when making these decisions, and both the CPU and the GPU is involved, the process itself can slow down rendering from the perspective of the required synchronization between the CPU and GPU. More on this below.</p>
<p>Basically there are 2 techniques. Both has the potential bottleneck of CPU-GPU synchronization.</p>
<p>One way is to rasterize the occluders into a <b>coverage buffer on the CPU</b>, and then the depth testing for the bounding boxes of the occludees can be done on the CPU as well. This way the CPU on its own can decide which objects are occluded and should be skipped, but the rest are actually need to be rendered by the GPU. The latency of this decision on the CPU can introduce GPU starvation.</p>
<p>The other technique is if we use the GPU for deciding which objects are occluded. For this, <b>HW occlusion queries</b> can be used. This involves similar technique: first render the occluders, and then for the bounding box of each occludee, start an occlusion query. Although the queries are started by the CPU, they are executed by the GPU. Still CPU has to make the decision of skipping actually occluded objects based on the HW query results, so the CPU might need to wait for them to be finished. The result will tell if any pixels or fragments of the bounding box passed the depth test. This can also introduce potential GPU starvation. Note that such HW occlusion queries are not supported by mobile GPUs, in such case the first CPU-based method should be used. <br  />
</p>
<h2><a class="anchor" id="occlusion_temporal_coherence"></a>
Solving Stalls by Exploiting Temporal Coherence</h2>
<p><b>Temporal coherence</b>: if we know what's visible and what's occluded in one frame, it is very likely that the same classification will be correct for most objects in the following frame as well. <br  />
 To get rid of potential pipeline stalls, in any of the above 2 cases, a more sophisticated approach is needed, where we use the information about occlusion during the rendering of the next frame. <br  />
 "Usually, if an object is visible one frame, it will be visible the next frame, and if it is not visible, it will not be visible the next frame. Of course, for most applications, "usually" isn't good enough. It is undesirable, but acceptable, to render an object that <em>isn't</em> visible, because that only costs performance. It is generally unacceptable to <em>not</em> render an object that <em>is</em> visible. <br  />
 The simplest approach is that visible objects should be checked every N frames (where, say, N=5) to see if they have become occluded, while objects that were occluded last frame must be rechecked again in the current frame to guarantee that they are still occluded. This will reduce the number of wasteful occlusion queries by almost a factor of N." <br  />
 (<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt">https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt</a>)</p>
<h2><a class="anchor" id="occlusion_simple_pseudocode"></a>
Simple Pseudo-code</h2>
<p>Pseudo-code for an async (non-stop-and-wait) way of querying:</p>
<div class="fragment"><div class="line">For every object, we need 3 variables:</div>
<div class="line"> - iOcclusionQuery - the ID of the OpenGL occlusion query;</div>
<div class="line"> - nFramesWithoutOcclusionTest - how many frames elapsed without testing <span class="keywordflow">if</span> the <span class="keywordtype">object</span> is occluded;</div>
<div class="line"> - bOccluded - the last result of occlusion query;</div>
<div class="line"> - bOcclusionQueryStarted - <span class="keywordflow">if</span> <span class="keyword">true</span>, there is an ongoing occlusion query <span class="keywordflow">for</span> <span class="keyword">this</span> <span class="keywordtype">object</span>.</div>
<div class="line"> </div>
<div class="line">When creating an object, an occlusion query <span class="keywordtype">object</span> should be created (but not started) <span class="keywordflow">for</span> it, and:</div>
<div class="line">  - iOcclusionQuery = the ID of the created OpenGL occlusion query;</div>
<div class="line">  - nFramesWithoutOcclusionTest = MAX_FRAMES_WO_OCCLUSION_TESTING;</div>
<div class="line">  - bOccluded = <span class="keyword">false</span>;</div>
<div class="line">  - bOcclusionQueryStarted = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">The bOcclusionQueryStarted member is needed because although theoretically we could get GL_GET_QUERY_AVAILABLE</div>
<div class="line"><span class="keywordflow">for</span> queries never yet started, I did not find any requirement on implementing the result <span class="keywordflow">for</span> GL_GET_QUERY_AVAILABLE</div>
<div class="line">when a query has never started yet. I<span class="stringliteral">&#39;m afraid of differences in implementations.</span></div>
<div class="line"><span class="stringliteral">I would rather maintain my own bOcclusionQueryStarted.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">Frustum cull your scene against any kind of object (translucent or opaque)</span></div>
<div class="line"><span class="stringliteral">Sort remaining objects opaque coarsely from front to back</span></div>
<div class="line"><span class="stringliteral">Render a z-pre-pass (no fragment shading, color masking turned on), maybe just large occluders here, like terrain, large buildings and stuff</span></div>
<div class="line"><span class="stringliteral">For each of N occludees:</span></div>
<div class="line"><span class="stringliteral">  - if ( nFramesWithoutOcclusionTest &gt;= MAX_FRAMES_WO_OCCLUSION_TESTING ):</span></div>
<div class="line"><span class="stringliteral">    - yes: either this has been declared as visible object for the previous few frames or this was declared as occluded in last frame or this is the first rendered frame;</span></div>
<div class="line"><span class="stringliteral">      - bOcclusionQueryStarted ?</span></div>
<div class="line"><span class="stringliteral">        - yes: nothing</span></div>
<div class="line"><span class="stringliteral">        - no:</span></div>
<div class="line"><span class="stringliteral">          - start query;</span></div>
<div class="line"><span class="stringliteral">          - bOcclusionQueryStarted = true;</span></div>
<div class="line"><span class="stringliteral">          - Disable color- and depth-writes (you’ll use the depth buffer written by rendering occluders):</span></div>
<div class="line"><span class="stringliteral">            - glColorMask(false, false, false, false);</span></div>
<div class="line"><span class="stringliteral">            - glDepthMask(false);</span></div>
<div class="line"><span class="stringliteral">          - &quot;Render&quot; bounding volume of occludee;</span></div>
<div class="line"><span class="stringliteral">          - end query;</span></div>
<div class="line"><span class="stringliteral">          - Enable color- and depth-writes:</span></div>
<div class="line"><span class="stringliteral">            - glColorMask(true, true, true, true); </span></div>
<div class="line"><span class="stringliteral">            - glDepthMask(true);</span></div>
<div class="line"><span class="stringliteral">    - no:</span></div>
<div class="line"><span class="stringliteral">      - nFramesWithoutOcclusionTest++;</span></div>
<div class="line"><span class="stringliteral">      - render the occludee if bOccluded is false, or always render it regardless bOccluded;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">  // this is intentionally not in else branch, so we check if query already finished in the same frame</span></div>
<div class="line"><span class="stringliteral">  // although I think I will see no query being finished in the same frame ... but this is the first approach!</span></div>
<div class="line"><span class="stringliteral">  // on the long run maybe we can move this into the yes-branch of the above &quot;bOcclusionQueryStarted ?&quot; condition</span></div>
<div class="line"><span class="stringliteral">  - bOcclusionQueryStarted ?</span></div>
<div class="line"><span class="stringliteral">    - yes:</span></div>
<div class="line"><span class="stringliteral">      - get(GL_GET_QUERY_AVAILABLE) ?</span></div>
<div class="line"><span class="stringliteral">        - no:</span></div>
<div class="line"><span class="stringliteral">          - render the occludee if bOccluded is false, or always render it regardless bOccluded;</span></div>
<div class="line"><span class="stringliteral">        - yes:</span></div>
<div class="line"><span class="stringliteral">          - bOcclusionQueryStarted = false;</span></div>
<div class="line"><span class="stringliteral">          - get query result;</span></div>
<div class="line"><span class="stringliteral">          - number of visible fragments is greater than 0 ?:</span></div>
<div class="line"><span class="stringliteral">            - yes:</span></div>
<div class="line"><span class="stringliteral">              - bOccluded = false;</span></div>
<div class="line"><span class="stringliteral">              - render the occludee object;</span></div>
<div class="line"><span class="stringliteral">              - nFramesWithoutOcclusionTest = 0;  // we can wait for a few frames before testing again</span></div>
<div class="line"><span class="stringliteral">            - no:</span></div>
<div class="line"><span class="stringliteral">              - bOccluded = true;</span></div>
<div class="line"><span class="stringliteral">              - nFramesWithoutOcclusionTest = MAX_FRAMES_WO_OCCLUSION_TESTING;   // this is occluded now, skip draw, but re-test is needed immediately!</span></div>
<div class="line"><span class="stringliteral">    - no: nothing.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">Render translucent object from back to front</span></div>
</div><!-- fragment --><h1><a class="anchor" id="chc"></a>
CHC: Coherent Hierarchical Culling</h1>
<p>"The algorithm exploits the spatial and temporal coherence of visibility. (...) <br  />
 <b>Spatial coherence</b>: storing the scene in a hierarchical data structure, processing nodes of the hierarchy in a front-to-back order. (...) If geometry is not the main rendering bottleneck, but rather the number of draw calls issued (Wloka 2003), then making additional draw calls to issue the occlusion queries is a performance loss. With hierarchies, though, interior nodes group a larger number of draw calls, which are all saved if the node is occluded using a single query. (...) <br  />
 <b>Temporal coherence</b>: if we know what's visible and what's occluded in one frame, it is very likely that the same classification will be correct for most objects in the following frame as well. (...) If we want to have correct images, we need to verify our guess and rectify our choice in case it was wrong. In the first case (the node was actually occluded), we update the classification for the next frame. In the second case (the node was actually visible), we just process (that is, traverse or render) the node normally. The good news is that we can do all of this later, whenever the query result arrives. Note also that the accuracy of our guess is not critical, because we are going to verify it anyway. (...) <br  />
 Issue occlusion queries only for previously visible leaf nodes and for the largest possible occluded nodes in the hierarchy (in other words, an occluded node is not tested if its parent is occluded as well). The number of queries issued is therefore linear in the number of visible objects." <br  />
 (<a href="https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-6-hardware-occlusion-queries-made-useful">https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-6-hardware-occlusion-queries-made-useful</a>) <br  />
 The algorithm can be further optimized with a few ideas mentioned on the page in "6.6 Optimizations".</p>
<p>"The CHC algorithm works well in densely occluded scenes, but the overhead of hardware occlusion queries makes it fall behind even simple view-frustum culling (VFC) in some situations. (...) It traverses the hierarchy in a front-to-back order and issues queries only for previously visible leaves and nodes of the previously invisible boundary. Previously visible leaves are assumed to stay visible in the current frame, and hence they are rendered immediately. The result of the query for these nodes only updates their classification for the next frame. The invisible nodes are assumed to stay invisible, but the algorithm retrieves the query result in the current frame in order to discover visibility changes. (...) The algorithm works very well for scenarios that have a lot of occlusion. However, on newer hardware where rendering geometry becomes cheap compared to querying, or view points where much of the scene is visible, the method can become even slower than conventional view-frustum culling. This is a result of wasted queries and unnecessary state changes." <br  />
 (<a href="https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/mattausch-2008-CHC-draft.pdf">https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/mattausch-2008-CHC-draft.pdf</a>)</p>
<h1><a class="anchor" id="chcpp"></a>
CHC++: Enhanced Coherent Hierarchical Culling</h1>
<p>CHC++: a further optimized form of CHC bringing much better speedup.</p>
<p>Following texts are citations from: <a href="https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/mattausch-2008-CHC-draft.pdf">https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/mattausch-2008-CHC-draft.pdf</a></p>
<p><b>Queues for batching of queries</b>: Before a node is queried, it is appended to a queue. Separate queues are used for accumulating previously visible and previously invisible nodes. We use the queues to issue batches of queries instead of individual queries. This reduces state changes by one to two orders of magnitude. <br  />
 Details: <br  />
 "It turns out that changes of rendering state cause an even larger overhead than the query itself. (...) Game developers refer to about 200 state changes per frame as an acceptable value on current hardware. The invisible nodes to be queried are appended to a queue which we call <b>i-queue</b>. When the number of nodes in the i-queue reaches a user-defined batch size b, we change the rendering state for querying and issue an occlusion query for each node in the i-queue. (...) <br  />
 Similarly to CHC, our proposed method renders the geometry of previously visible nodes during the hierarchy traversal. However the queries are not issued immediately. Instead the corresponding nodes are stored in a queue which we call <b>v-queue</b>. (...) The queries for these nodes are not critical for the current frame since their result will only be used in the next frame. We exploit this observation by using nodes from the v-queue to fill up waiting time: whenever the traversal queue is empty and no outstanding query result is available, we process nodes from the v-queue. (...) <br  />
 We propose to use an additional queue in the algorithm which we call <b>render queue</b>. This queue accumulates all nodes scheduled for rendering and is processed when a batch of queries is about to be issued. When processing the render queue the engine can apply its internal material shader sorting and then render the objects stored in the queue in the new order."</p>
<p><b>Multiqueries</b>. We compile multiqueries (Section 5.1), which are able to cover more nodes by a single occlusion query. This reduces the number of queries for previously invisible nodes up to an order of magnitude. <br  />
 Details: <br  />
 "If some previously invisible part of a scene remains invisible in the current frame, a single occlusion query for the whole part is sufficient to verify its visibility status. Such a query would render all bounding boxes of primitives in this scene part, and return zero if all primitives remain occluded. (...) Our new technique aims to identify such scene parts by forming groups of previously invisible nodes that are equally likely to remain invisible. A single occlusion query is issued for each such group, which we call a multiquery. If the multiquery returns zero, all nodes in the group remain invisible and their status has been updated by the single query. Otherwise the coherence was broken for this group and we issue individual queries for all nodes by reinserting them in the i-queue."</p>
<p><b>Randomized sampling pattern for visible nodes</b>. We apply a temporally jittered sampling pattern (Section 5.2) for scheduling queries for previously visible nodes. This reduces the number of queries for visible nodes and while spreading them evenly over the frames of the walkthrough. <br  />
 Details: <br  />
 "The original CHC algorithm introduced an important optimization in order to reduce the number of queries on previously visible nodes. A visible node is assumed to stay visible for nav frames and it will only be tested in the frame nav +1. (...) This simple method however has a problem that the queries can be temporally aligned. This query alignment becomes problematic in situations when nodes tend to become visible in the same frame. (...) The average number of queries per frame will still be reduced, but the alignment can cause observable frame rate drops. (...) <br  />
 We found that the most satisfying solution is achieved by randomizing the first invocation of the occlusion query. After a node has turned visible, we use a random value 0 &lt; r &lt; nav for determining the next frame when a query will be issued. Subsequently, if the node was already visible in the previous test, we use a regular sampling interval given by nav."</p>
<p><b>Tight bounding volumes</b>. We use tight bounding volumes (Section 6) without the need for their explicit construction. This provides a reduction of the number of rendered triangles as well as a reduction of the number of queries. <br  />
 Details: <br  />
 "We propose a simple method for determining tighter bounds for inner nodes in the context of hardware occlusion queries applied to an arbitrary bounding volume hierarchy. For a particular node we determine its tight bounding volume as a collection of bounding volumes of its children at a particular depth. (...) <br  />
 Tight bounding volumes provide several benefits at almost no cost: (1) earlier culling of interior nodes of the hierarchy, (2) culling of leaves which would otherwise be classified as visible, (3) increase of coherence of visibility classification of interior nodes. The first property leads to a reduction of the number of queries. The second property provides a reduction of the number of rendered triangles. Finally, the third benefit avoids changes in visibility classification for interior nodes caused by repeated pull-up and pull-down of visibility."</p>
<h1><a class="anchor" id="occlusion_materials"></a>
Materials to Read</h1>
<p><a href="https://documents.pub/document/visibility-optimization-for-games-sampo-lappalainen-lead-programmer-umbra-software-ltd.html">https://documents.pub/document/visibility-optimization-for-games-sampo-lappalainen-lead-programmer-umbra-software-ltd.html</a> <br  />
 documents.pub_visibility-optimization-for-games-sampo-lappalainen-lead-programmer-umbra-software-ltd.ppt <br  />
</p>
<p><a href="https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling">https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling</a> <br  />
 <a href="https://community.khronos.org/t/occlusion-culling-with-arb-occlusion-query/68688/4">https://community.khronos.org/t/occlusion-culling-with-arb-occlusion-query/68688/4</a> <br  />
 <a href="https://gamedev.stackexchange.com/questions/118651/opengl-occlusion-culling-huge-performance-drop">https://gamedev.stackexchange.com/questions/118651/opengl-occlusion-culling-huge-performance-drop</a> <br  />
 <a href="https://github.com/ychding11/GraphicsCollection/wiki/Occlusion-Culling-and-Visibility-Filter-in-Graphics">https://github.com/ychding11/GraphicsCollection/wiki/Occlusion-Culling-and-Visibility-Filter-in-Graphics</a> <br  />
 CHC: <a href="https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-6-hardware-occlusion-queries-made-useful">https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-6-hardware-occlusion-queries-made-useful</a> <br  />
 CHC++: <a href="https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/">https://www.cg.tuwien.ac.at/research/publications/2008/mattausch-2008-CHC/</a> <br  />
 (mattausch-2008-CHC-draft.pdf) <br  />
 Battlefield: Bad Company: <a href="https://blog.selfshadow.com/publications/practical-visibility/">https://blog.selfshadow.com/publications/practical-visibility/</a> <br  />
 <a href="https://software.intel.com/content/www/us/en/develop/topics/gamedev.html">https://software.intel.com/content/www/us/en/develop/topics/gamedev.html</a></p>
<p>Software Occlusion Culling <br  />
 <a href="https://software.intel.com/content/www/us/en/develop/articles/software-occlusion-culling.html">https://software.intel.com/content/www/us/en/develop/articles/software-occlusion-culling.html</a> <br  />
 <a href="https://software.intel.com/content/www/us/en/develop/articles/masked-software-occlusion-culling.html">https://software.intel.com/content/www/us/en/develop/articles/masked-software-occlusion-culling.html</a> <br  />
 <a href="https://software.intel.com/content/www/us/en/develop/articles/merging-masked-occlusion-culling-hierarchical-buffers-for-faster-rendering.html">https://software.intel.com/content/www/us/en/develop/articles/merging-masked-occlusion-culling-hierarchical-buffers-for-faster-rendering.html</a></p>
<p>Core Techniques and Algorithms in Game Programming - Daniel Sanchez-Crespo Dalmau.pdf <br  />
 3D Game Engine Architecture - Engineering Real Time Applications with Wild Magic - David H. Eberl.pdf <br  />
 3D Game Engine Design - David H. Eberly.pdf</p>
<h1><a class="anchor" id="occlusion_extensions"></a>
OpenGL Extensions for HW Occlusion Culling Support</h1>
<p>There are some online OpenGL capability reports can be used to find out how widely an extension is supported: <br  />
 <a href="https://www.gpuinfo.org/">https://www.gpuinfo.org/</a> <br  />
 <a href="https://opengl.gpuinfo.org/listextensions.php">https://opengl.gpuinfo.org/listextensions.php</a> <br  />
 <a href="https://opengles.gpuinfo.org/">https://opengles.gpuinfo.org/</a> <br  />
 <a href="https://feedback.wildfiregames.com/report/opengl/">https://feedback.wildfiregames.com/report/opengl/</a> <br  />
</p>
<h2><a class="anchor" id="GL_HP_occlusion_test"></a>
GL_HP_occlusion_test</h2>
<ul>
<li><a href="https://www.scitepress.org/Papers/2007/20725/20725.pdf">https://www.scitepress.org/Papers/2007/20725/20725.pdf</a> <br  />
</li>
<li>GDC2002_occlusion.pdf <br  />
</li>
<li>SimpleFastHWaccelPoint-in-PolygonTest.pdf <br  />
</li>
<li>was supported in early 2000s, also supported by Geforce 7600 GT in 2006 <br  />
</li>
<li>doesn't look to be supported by Geforce 1060 GT in 2021 <br  />
</li>
<li>Desktop: Looks like for some reason vendors supported it around 2005-2007, but then they stopped supporting it! <br  />
 Mobile: no support at all! <br  />
</li>
<li>simple GL_TRUE/GL_FALSE result; <br  />
</li>
<li>simple "stop-and-wait" model for using multiple queries. The application begins an occlusion test and ends it; <br  />
 then, at some later point, it asks for the result, at which point the driver must stop and wait until the result <br  />
 from the previous test is back before the application can even begin the next one. This means that usage of this <br  />
 is not recommended as it can easily stall the graphics pipeline. <br  />
</li>
<li><b>Verdict: don't use it.</b></li>
</ul>
<h2><a class="anchor" id="GL_HP_visibility_test"></a>
GL_HP_visibility_test</h2>
<ul>
<li><a href="http://www.vgamuseum.info/images/doc/profi/hpfx10.txt">http://www.vgamuseum.info/images/doc/profi/hpfx10.txt</a> <br  />
</li>
<li>Desktop: nothing found. <br  />
 Mobile: nothing found. <br  />
</li>
<li>improves upon HP's occlusion test extension by letting applications perform multiple visibility tests before getting <br  />
 back the results. This is different than the occlusion test extension which provides only a single visibility test result. <br  />
 To perform multiple visibility tests with the occlusion test extension, the result of the previous test must be obtained before <br  />
 starting a new test. With the Visibility Test extension, performance is improved because the results of many tests can be obtained in <br  />
 a single call. <br  />
</li>
<li><b>Verdict: don't use it.</b></li>
</ul>
<h2><a class="anchor" id="GL_HP_visibility_stats"></a>
GL_HP_visibility_stats</h2>
<ul>
<li><a href="http://www.vgamuseum.info/images/doc/profi/hpfx10.txt">http://www.vgamuseum.info/images/doc/profi/hpfx10.txt</a> <br  />
</li>
<li>Desktop: nothing found. <br  />
 Mobile: nothing found. <br  />
</li>
<li>Visibility Statistics is a logical extension to HP's occlusion test and visibility test extensions. While visibility testing gives a <br  />
 binary answer of visible or NOT visible, visibility statistics gives a quantative answer of how visible in the form of a pass count and <br  />
 a fail count. Applications can use these counts to compute "percent visible" numbers and use the results in Level Of Detail (LOD) algorithms. <br  />
</li>
<li><b>Verdict: don't use it.</b></li>
</ul>
<h2><a class="anchor" id="GL_NV_occlusion_query"></a>
GL_NV_occlusion_query</h2>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_occlusion_query.txt">https://www.khronos.org/registry/OpenGL/extensions/NV/NV_occlusion_query.txt</a> <br  />
</li>
<li>GDC2002_occlusion.pdf <br  />
</li>
<li>vendor-specification from around 2002; <br  />
</li>
<li>Desktop: some NV and AMD drivers support it; <br  />
 Mobile: nothing found. <br  />
</li>
<li>not supported widely enough, better to favor standard GL_ARB_occlusion_query <br  />
</li>
<li><b>Verdict: don't use this.</b></li>
</ul>
<h2><a class="anchor" id="GL_NV_occlusion_query_samples"></a>
GL_NV_occlusion_query_samples</h2>
<ul>
<li>cannot even find an official page about this extension; <br  />
</li>
<li>Desktop: nothing found. <br  />
 Mobile: only with nvidia Tegra! <br  />
</li>
<li><b>Verdict: don't use this.</b></li>
</ul>
<h2><a class="anchor" id="GL_ARB_occlusion_query"></a>
GL_ARB_occlusion_query</h2>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt">https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query.txt</a> <br  />
</li>
<li>2003 <br  />
</li>
<li>its result the number of samples that pass the depth and stencil tests. Samples are counted immediately after <br  />
 <em>both</em> the depth and stencil tests, i.e., samples that pass both; <br  />
</li>
<li>occlusion queries in "query objects" that allow applications to issue many queries before asking for the result of <br  />
 any one. As a result, they can overlap the time it takes for the occlusion query results to be returned with other, <br  />
 more useful work, such as rendering other parts of the scene or performing other computations on the CPU; <br  />
</li>
<li>occlusion queries return in order. If occlusion test X occurred before occlusion query Y, and the driver informs the app <br  />
 that occlusion query Y is done, the app can infer that occlusion query X is also done. <br  />
</li>
<li>the polling method introduced in the NV_occlusion_query spec allowed for a potential infinite loop if the application <br  />
 does not do a flush. This version of the spec clarifies the behavior which now makes such a flush unnecessary. <br  />
</li>
<li>"An implementation can either set QUERY_COUNTER_BITS_ARB to the value 0, or to some number greater than or equal to n. <br  />
 If an implementation returns 0 for QUERY_COUNTER_BITS_ARB, then the occlusion queries will always return that zero samples <br  />
 passed the occlusion test, and so an application should not use occlusion queries on that implementation." <br  />
</li>
<li>Desktop: widely supported. <br  />
 Mobile: nothing found. <br  />
</li>
<li><b>Verdict: use this for desktop.</b></li>
</ul>
<h2><a class="anchor" id="GL_ARB_occlusion_query2"></a>
GL_ARB_occlusion_query2</h2>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query2.txt">https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query2.txt</a> <br  />
</li>
<li><a href="https://www.diva-portal.org/smash/get/diva2:830875/FULLTEXT01.pdf">https://www.diva-portal.org/smash/get/diva2:830875/FULLTEXT01.pdf</a> <br  />
</li>
<li>2010, looks to be widely supported until today <br  />
</li>
<li>depends on GL_ARB_occlusion_query, the difference is that it can simply return bool true/false instead of the number <br  />
 of passing samples. Probably faster, since it can stop the query at the first passing fragment depth test. Need to verify this though. <br  />
</li>
<li><b>Verdict: use this for desktop.</b> Unclear if it has speed advantage over the first version if this ext.</li>
</ul>
<h2><a class="anchor" id="GL_EXT_occlusion_query_boolean"></a>
GL_EXT_occlusion_query_boolean</h2>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_occlusion_query_boolean.txt">https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_occlusion_query_boolean.txt</a> <br  />
</li>
<li>2011 <br  />
</li>
<li>I guess this is more likely for mobile instead of GL_ARB_occlusion_query2; <br  />
</li>
<li>This is also async query as GL_ARB_occlusion_query, so it can avoid stalling pipeline; <br  />
</li>
<li>Desktop: nothing found. <br  />
 Mobile: lot of Mali, Tegra, Rogue, SGX chips support it. <br  />
</li>
<li><b>Verdict: use this for mobile.</b> Note that, even in 2020, article states that occlusion culling on mobile is slow, and <br  />
 a software occlusion culling implementation is recommended. In Unreal engine, software occlusion culling is recommended: <br  />
 <a href="https://docs.microsoft.com/en-us/windows/mixed-reality/develop/unreal/performance-recommendations-for-unreal">https://docs.microsoft.com/en-us/windows/mixed-reality/develop/unreal/performance-recommendations-for-unreal</a> <br  />
 Software occlusion culling like PVS and/or partial software rendering to find out if something is occluded or not. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="visibility.html">Visibility Optimizations</a></li>
    <li class="footer">Generated on Mon Nov 1 2021 22:00:13 for PURE API by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
