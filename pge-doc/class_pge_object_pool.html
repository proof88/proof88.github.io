<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PGE API: PgeObjectPool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="pure_doxystyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PGE API<span id="projectnumber">&#160;0.4</span>
   </div>
   <div id="projectbrief">PR00F&#39;s Game Engine full documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_pge_object_pool.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="class_pge_object_pool-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle"><div class="title">PgeObjectPool&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>PR00F's Game Engine object pool for permanently allocating fixed number of game objects.  
 <a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class PgeObjectPool&lt; T &gt;</div><p>PR00F's Game Engine object pool for permanently allocating fixed number of game objects. </p>
<p>The aim of this class is to have a fixed number of objects being kept in contiguous memory area, and to be able to distinguish between them as they are free for use or busy (being used).</p>
<p>This way we just flag the preallocated objects, instead of actually creating or deleting them in memory which would be otherwise performance-expensive operation, especially when we are talking about resource-heavy objects such as PureObject3D or even higher-level game instances.</p>
<p>Thus, I expect this pool to be used for storing objects created and deleted with high frequency, such as bullets fired from weapons, particles, etc.</p>
<p>Since these virtual "create" and "delete" operations are expected to happen multiple times within 1 frame, I want them to have O(1) complexity.</p>
<p>Also, since they are in contiguous memory area, and usually higher-level logic iterates over them from begin to end, it is more cache-friendly than iterating over occasionally allocated objects that are placed here and there in memory.</p>
<p>The only downsides of having such preallocated object pool is that:</p><ul>
<li>we need to have a good guess for the number of required objects to be allocated at the beginning;</li>
<li>these preallocated objects are always using memory capacity even when not all is needed.</li>
</ul>
<p>However, the advantages regarding performance are outweighing these small disadvantages.</p>
<p>Basically this class is based on this "Object Pool Pattern": <a href="https://gameprogrammingpatterns.com/object-pool.html">https://gameprogrammingpatterns.com/object-pool.html</a> .</p>
<p>Also, for iterators, I'm using Vincenzo Barbato's <a class="el" href="namespacebl_iterator_a_p_i.html">blIteratorAPI</a>: <a href="https://github.com/navyenzo/blIteratorAPI">https://github.com/navyenzo/blIteratorAPI</a> . Note that you might need to define the _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING macro for the MSVC preprocessor, it comes from the way of how <a class="el" href="namespacebl_iterator_a_p_i.html">blIteratorAPI</a> is implemented. It is safe to silence this warning.</p>
<p>Reminder: this class is NOT a memory pool neither a memory manager. This is an object pool with fixed number of objects, and after construction, no more memory allocation happens! For memory pool management, I would rather use an already existing solution from these:</p><ul>
<li><a href="https://github.com/gperftools/gperftools">https://github.com/gperftools/gperftools</a></li>
<li><a href="https://jemalloc.net/">https://jemalloc.net/</a></li>
<li><a href="https://github.com/electronicarts/EASTL">https://github.com/electronicarts/EASTL</a></li>
<li><a href="https://github.com/cacay/MemoryPool/tree/master">https://github.com/cacay/MemoryPool/tree/master</a></li>
<li><a href="https://github.com/lenonk/memorypool">https://github.com/lenonk/memorypool</a></li>
<li><a href="https://github.com/danielkrupinski/StringPool?tab=readme-ov-file">https://github.com/danielkrupinski/StringPool?tab=readme-ov-file</a></li>
</ul>
<p>Ideas on improving:</p><ul>
<li>not all iterators can compile currently, as you can see in the unit tests, only <a class="el" href="#a65588c008acdb3ceff1971447303b1e9" title="Gives iterator for beginning iterating over the contiguous memory area of pooled objects,...">begin()</a> and <a class="el" href="#ae5f8a3a2a673e3def1a14df87061d873" title="Gives iterator for ending iterating over the contiguous memory area of pooled objects,...">end()</a> are working, but const and reverse iterators don't compile due to warnings and else, need time to fix that in <a class="el" href="namespacebl_iterator_a_p_i.html">blIteratorAPI</a>.</li>
<li>would be nice to implement iterating over only used elems, so that loops would not need to check elem.used(), and this should utilize the elem's next ptr, because currently only the unused elems' next ptr has meaningful value, but the used elem's next ptr is not used for anything, this should be changed to point to next used elem, and then we could have 2 separate lists, 1 with unused elems and 1 with used elems.</li>
<li>would be useful to have a bool autoReuseOldestElems flag: it would make difference when <a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d" title="Finds a free (usable) object in the pool, sets it flag as used and returns it.">create()</a> detects no free object is available. If flag is false, simply return without doing anything (current behavior). If true, it would reuse the oldest used elem, updated with the given params. Use case: for example, particles, like rocket smoke: if pool capacity is reached, it would make sense to reuse the oldest emitted smoke objects, instead of not doing anything.</li>
<li>modify <a class="el" href="namespacebl_iterator_a_p_i.html">blIteratorAPI</a> so that _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING definition would not be needed. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00209">209</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for PgeObjectPool&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_pge_object_pool.png" usemap="#PgeObjectPool_3C_20T_20_3E_map" alt=""/>
  <map id="PgeObjectPool_3C_20T_20_3E_map" name="PgeObjectPool_3C_20T_20_3E_map">
<area href="class_pge_object_pool_base.html" title="Base class for pool only to have a non-template base so we can use it as non-void pointer in PgePoole..." alt="PgeObjectPoolBase" shape="rect" coords="0,0,127,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1db3c9df14274db3eab69ed8b2b36627" id="r_a1db3c9df14274db3eab69ed8b2b36627"><td class="memItemLeft" align="right" valign="top">CConsole &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db3c9df14274db3eab69ed8b2b36627">getConsole</a> () const</td></tr>
<tr class="separator:a1db3c9df14274db3eab69ed8b2b36627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015904e17d5af838343825f733dc85f2" id="r_a015904e17d5af838343825f733dc85f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015904e17d5af838343825f733dc85f2">PgeObjectPool</a> ()</td></tr>
<tr class="memdesc:a015904e17d5af838343825f733dc85f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor should be used when parameters for initializing the pool is NOT available.  <br /></td></tr>
<tr class="separator:a015904e17d5af838343825f733dc85f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3140f243e2a97e037e9c305da3c6612e" id="r_a3140f243e2a97e037e9c305da3c6612e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3140f243e2a97e037e9c305da3c6612e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3140f243e2a97e037e9c305da3c6612e">PgeObjectPool</a> (const std::string &amp;poolName, const size_t &amp;<a class="el" href="#a07467a1127165555602b783605c8fb91">capacity</a>, Args &amp;&amp;... pooledObjArgs)</td></tr>
<tr class="memdesc:a3140f243e2a97e037e9c305da3c6612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not only the memory pool is allocated for all pooled objects, but their non-default constructor is also called with the provided pooled object parameters, or their default constructor if that is available.  <br /></td></tr>
<tr class="separator:a3140f243e2a97e037e9c305da3c6612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7a0002a2e21bac3871dad3775bfeff" id="r_a7f7a0002a2e21bac3871dad3775bfeff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f7a0002a2e21bac3871dad3775bfeff">~PgeObjectPool</a> ()</td></tr>
<tr class="separator:a7f7a0002a2e21bac3871dad3775bfeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061d820d66f696a48170edc450b91caf" id="r_a061d820d66f696a48170edc450b91caf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a061d820d66f696a48170edc450b91caf">PgeObjectPool</a> (const <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;)=delete</td></tr>
<tr class="separator:a061d820d66f696a48170edc450b91caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dcd69f4a802cfbb64f883f19cc455e" id="r_a49dcd69f4a802cfbb64f883f19cc455e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49dcd69f4a802cfbb64f883f19cc455e">operator=</a> (const <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;)=delete</td></tr>
<tr class="separator:a49dcd69f4a802cfbb64f883f19cc455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65856161a0152382aaa33273b4e86fb" id="r_aa65856161a0152382aaa33273b4e86fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65856161a0152382aaa33273b4e86fb">PgeObjectPool</a> (<a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aa65856161a0152382aaa33273b4e86fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea7d720e7ac3b82a1ee56222a10e493" id="r_aeea7d720e7ac3b82a1ee56222a10e493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea7d720e7ac3b82a1ee56222a10e493">operator=</a> (<a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aeea7d720e7ac3b82a1ee56222a10e493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00764fa2c24334a7ea2c0730b6b9ab69" id="r_a00764fa2c24334a7ea2c0730b6b9ab69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00764fa2c24334a7ea2c0730b6b9ab69">deallocate</a> ()</td></tr>
<tr class="memdesc:a00764fa2c24334a7ea2c0730b6b9ab69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up the allocated contiguous memory pool, capacity becomes zero, name becomes "unnamed pool".  <br /></td></tr>
<tr class="separator:a00764fa2c24334a7ea2c0730b6b9ab69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4fb79cb2ec825eb2a237f848be733e" id="r_aed4fb79cb2ec825eb2a237f848be733e"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4fb79cb2ec825eb2a237f848be733e">count</a> () const</td></tr>
<tr class="separator:aed4fb79cb2ec825eb2a237f848be733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a1ce9c67982b05a88123703b46d2e4" id="r_ab1a1ce9c67982b05a88123703b46d2e4"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1a1ce9c67982b05a88123703b46d2e4">size</a> () const</td></tr>
<tr class="memdesc:ab1a1ce9c67982b05a88123703b46d2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventionally std containers have a <a class="el" href="#ab1a1ce9c67982b05a88123703b46d2e4" title="Conventionally std containers have a size() member function returning the number of elements,...">size()</a> member function returning the number of elements, NOT the capacity.  <br /></td></tr>
<tr class="separator:ab1a1ce9c67982b05a88123703b46d2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07467a1127165555602b783605c8fb91" id="r_a07467a1127165555602b783605c8fb91"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07467a1127165555602b783605c8fb91">capacity</a> () const</td></tr>
<tr class="separator:a07467a1127165555602b783605c8fb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca712857635da9dc6d9ed16ff5f8a55" id="r_a6ca712857635da9dc6d9ed16ff5f8a55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca712857635da9dc6d9ed16ff5f8a55">capacityBytes</a> () const</td></tr>
<tr class="separator:a6ca712857635da9dc6d9ed16ff5f8a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ceb71308c79d7324bc1d01d3fef14" id="r_a1a5ceb71308c79d7324bc1d01d3fef14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5ceb71308c79d7324bc1d01d3fef14">empty</a> () const</td></tr>
<tr class="separator:a1a5ceb71308c79d7324bc1d01d3fef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b610874a5f5ca6edd2407f0c19eee" id="r_a7f4b610874a5f5ca6edd2407f0c19eee"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4b610874a5f5ca6edd2407f0c19eee">name</a> () const</td></tr>
<tr class="separator:a7f4b610874a5f5ca6edd2407f0c19eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14318f7ccdb1a30d2ef66e076be72c8d" id="r_a14318f7ccdb1a30d2ef66e076be72c8d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a14318f7ccdb1a30d2ef66e076be72c8d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d">create</a> (Args &amp;&amp;... pooledObjArgs)</td></tr>
<tr class="memdesc:a14318f7ccdb1a30d2ef66e076be72c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a free (usable) object in the pool, sets it flag as used and returns it.  <br /></td></tr>
<tr class="separator:a14318f7ccdb1a30d2ef66e076be72c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146702259b9f12890b20d71e3a63f10c" id="r_a146702259b9f12890b20d71e3a63f10c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a146702259b9f12890b20d71e3a63f10c">remove</a> (<a class="el" href="class_pge_pooled_object.html">PgePooledObject</a> &amp;obj)</td></tr>
<tr class="memdesc:a146702259b9f12890b20d71e3a63f10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the free (usable) flag of this object, "returns it" into the pool so it can be reused again.  <br /></td></tr>
<tr class="separator:a146702259b9f12890b20d71e3a63f10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a34a5032ed41cad1e47dd16261c2b" id="r_a340a34a5032ed41cad1e47dd16261c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a340a34a5032ed41cad1e47dd16261c2b">erase</a> (typename <a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator itPos)</td></tr>
<tr class="memdesc:a340a34a5032ed41cad1e47dd16261c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the free (usable) flag of the pooled object pointed by the given iterator, "returns" the object into the pool so it can be reused again.  <br /></td></tr>
<tr class="separator:a340a34a5032ed41cad1e47dd16261c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c08a81eb66c2445fb620056e3d312cf" id="r_a4c08a81eb66c2445fb620056e3d312cf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4c08a81eb66c2445fb620056e3d312cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf">reserve</a> (const std::string &amp;poolName, const size_t &amp;<a class="el" href="#a07467a1127165555602b783605c8fb91">capacity</a>, Args &amp;&amp;... pooledObjArgs)</td></tr>
<tr class="memdesc:a4c08a81eb66c2445fb620056e3d312cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not only the memory pool is allocated for all pooled objects, but their non-default constructor is also called with the provided pooled object parameters, or their default constructor if that is available.  <br /></td></tr>
<tr class="separator:a4c08a81eb66c2445fb620056e3d312cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbeda64cb71bbaf76fb1051fd95c020" id="r_abbbeda64cb71bbaf76fb1051fd95c020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbbeda64cb71bbaf76fb1051fd95c020">clear</a> ()</td></tr>
<tr class="memdesc:abbbeda64cb71bbaf76fb1051fd95c020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the free (usable) flag of all objects in the pool, "returns them" into the pool so they can be reused again.  <br /></td></tr>
<tr class="separator:abbbeda64cb71bbaf76fb1051fd95c020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b59dae6a04fe53a1c64ff0b623db7b9" id="r_a2b59dae6a04fe53a1c64ff0b623db7b9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems</a> ()</td></tr>
<tr class="separator:a2b59dae6a04fe53a1c64ff0b623db7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0760f85a6d31a3a24e9a47b113ed7" id="r_acef0760f85a6d31a3a24e9a47b113ed7"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acef0760f85a6d31a3a24e9a47b113ed7">elems</a> () const</td></tr>
<tr class="separator:acef0760f85a6d31a3a24e9a47b113ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050a88273d652636562ceac6a008aaab" id="r_a050a88273d652636562ceac6a008aaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a050a88273d652636562ceac6a008aaab">rawArrayWrapper</a> ()</td></tr>
<tr class="separator:a050a88273d652636562ceac6a008aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65588c008acdb3ceff1971447303b1e9" id="r_a65588c008acdb3ceff1971447303b1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65588c008acdb3ceff1971447303b1e9">begin</a> ()</td></tr>
<tr class="memdesc:a65588c008acdb3ceff1971447303b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives iterator for beginning iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a65588c008acdb3ceff1971447303b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f8a3a2a673e3def1a14df87061d873" id="r_ae5f8a3a2a673e3def1a14df87061d873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5f8a3a2a673e3def1a14df87061d873">end</a> ()</td></tr>
<tr class="memdesc:ae5f8a3a2a673e3def1a14df87061d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives iterator for ending iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:ae5f8a3a2a673e3def1a14df87061d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80516b700d455e1b9e246ae766a68656" id="r_a80516b700d455e1b9e246ae766a68656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80516b700d455e1b9e246ae766a68656">cbegin</a> () const</td></tr>
<tr class="memdesc:a80516b700d455e1b9e246ae766a68656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives const iterator for beginning iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a80516b700d455e1b9e246ae766a68656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8d935df50d4332d237b7dd0b0845e7" id="r_a4f8d935df50d4332d237b7dd0b0845e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8d935df50d4332d237b7dd0b0845e7">cend</a> () const</td></tr>
<tr class="memdesc:a4f8d935df50d4332d237b7dd0b0845e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives const iterator for ending iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a4f8d935df50d4332d237b7dd0b0845e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff05e8f5b65ef8039087dd2f754df9" id="r_a2bff05e8f5b65ef8039087dd2f754df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bff05e8f5b65ef8039087dd2f754df9">rbegin</a> ()</td></tr>
<tr class="memdesc:a2bff05e8f5b65ef8039087dd2f754df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives iterator for beginning reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a2bff05e8f5b65ef8039087dd2f754df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c3b174b3aa6bcfc79d90e8890befc3" id="r_a40c3b174b3aa6bcfc79d90e8890befc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c3b174b3aa6bcfc79d90e8890befc3">rend</a> ()</td></tr>
<tr class="memdesc:a40c3b174b3aa6bcfc79d90e8890befc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives iterator for ending reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a40c3b174b3aa6bcfc79d90e8890befc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a51119cc8723ea7cf0f1be60953ff4" id="r_ae9a51119cc8723ea7cf0f1be60953ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a51119cc8723ea7cf0f1be60953ff4">crbegin</a> () const</td></tr>
<tr class="memdesc:ae9a51119cc8723ea7cf0f1be60953ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives const iterator for beginning reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:ae9a51119cc8723ea7cf0f1be60953ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99530f19f172b4b9d27aab5fc956b9bb" id="r_a99530f19f172b4b9d27aab5fc956b9bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99530f19f172b4b9d27aab5fc956b9bb">crend</a> () const</td></tr>
<tr class="memdesc:a99530f19f172b4b9d27aab5fc956b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives const iterator for ending reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns.  <br /></td></tr>
<tr class="separator:a99530f19f172b4b9d27aab5fc956b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_pge_object_pool_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_pge_object_pool_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a></td></tr>
<tr class="memitem:a88feccea12499dbbf3a82ffc765425b9 inherit pub_methods_class_pge_object_pool_base" id="r_a88feccea12499dbbf3a82ffc765425b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#a88feccea12499dbbf3a82ffc765425b9">PgeObjectPoolBase</a> ()=default</td></tr>
<tr class="separator:a88feccea12499dbbf3a82ffc765425b9 inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55a609247777c304fd6cf68fb6841ef inherit pub_methods_class_pge_object_pool_base" id="r_ac55a609247777c304fd6cf68fb6841ef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#ac55a609247777c304fd6cf68fb6841ef">~PgeObjectPoolBase</a> ()=default</td></tr>
<tr class="separator:ac55a609247777c304fd6cf68fb6841ef inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f7c8ab5f5dddef9b3273f88c2301d7 inherit pub_methods_class_pge_object_pool_base" id="r_ab1f7c8ab5f5dddef9b3273f88c2301d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#ab1f7c8ab5f5dddef9b3273f88c2301d7">PgeObjectPoolBase</a> (const <a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;)=default</td></tr>
<tr class="separator:ab1f7c8ab5f5dddef9b3273f88c2301d7 inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe90ae825443ea6f96eb576d2679fc inherit pub_methods_class_pge_object_pool_base" id="r_a57fe90ae825443ea6f96eb576d2679fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#a57fe90ae825443ea6f96eb576d2679fc">operator=</a> (const <a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;)=default</td></tr>
<tr class="separator:a57fe90ae825443ea6f96eb576d2679fc inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80decd7e014e30a4b142cd21001c01 inherit pub_methods_class_pge_object_pool_base" id="r_aff80decd7e014e30a4b142cd21001c01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#aff80decd7e014e30a4b142cd21001c01">PgeObjectPoolBase</a> (<a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aff80decd7e014e30a4b142cd21001c01 inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ecbc5e9160532fbf76eb96c67a9bf9 inherit pub_methods_class_pge_object_pool_base" id="r_aa8ecbc5e9160532fbf76eb96c67a9bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pge_object_pool_base.html#aa8ecbc5e9160532fbf76eb96c67a9bf9">operator=</a> (<a class="el" href="class_pge_object_pool_base.html">PgeObjectPoolBase</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa8ecbc5e9160532fbf76eb96c67a9bf9 inherit pub_methods_class_pge_object_pool_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a710b5e8484a8520de72e4097ec90b204" id="r_a710b5e8484a8520de72e4097ec90b204"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710b5e8484a8520de72e4097ec90b204">getLoggerModuleName</a> ()</td></tr>
<tr class="separator:a710b5e8484a8520de72e4097ec90b204"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9553dc63d71d83a113ecadf30cb817d9" id="r_a9553dc63d71d83a113ecadf30cb817d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9553dc63d71d83a113ecadf30cb817d9">m_name</a> {}</td></tr>
<tr class="separator:a9553dc63d71d83a113ecadf30cb817d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7380eadf447750c4eaeac72f3b1029" id="r_abc7380eadf447750c4eaeac72f3b1029"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7380eadf447750c4eaeac72f3b1029">m_count</a> {0}</td></tr>
<tr class="separator:abc7380eadf447750c4eaeac72f3b1029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d271c74ed27f1ee639dc99a15768cd" id="r_a27d271c74ed27f1ee639dc99a15768cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d271c74ed27f1ee639dc99a15768cd">m_capacity</a> {0}</td></tr>
<tr class="separator:a27d271c74ed27f1ee639dc99a15768cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40134cb0ed65549c9f413d5f72cfccc5" id="r_a40134cb0ed65549c9f413d5f72cfccc5"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40134cb0ed65549c9f413d5f72cfccc5">m_pool</a> {nullptr}</td></tr>
<tr class="separator:a40134cb0ed65549c9f413d5f72cfccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e504cdfaa86b001540208fe049841e9" id="r_a0e504cdfaa86b001540208fe049841e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pge_pooled_object.html">PgePooledObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e504cdfaa86b001540208fe049841e9">m_firstAvailable</a> {nullptr}</td></tr>
<tr class="separator:a0e504cdfaa86b001540208fe049841e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb4a10b9984f4dcf95b6f632dd37d81" id="r_abcb4a10b9984f4dcf95b6f632dd37d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb4a10b9984f4dcf95b6f632dd37d81">m_rawArrayWrapper</a></td></tr>
<tr class="separator:abcb4a10b9984f4dcf95b6f632dd37d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a015904e17d5af838343825f733dc85f2" name="a015904e17d5af838343825f733dc85f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015904e17d5af838343825f733dc85f2">&#9670;&#160;</a></span>PgeObjectPool() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;<a class="el" href="class_pge_object_pool.html">::PgeObjectPool</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor should be used when parameters for initializing the pool is NOT available. </p>
<p>In this case, no memory is allocated, size remains 0, and later the pool needs to be initialized using <a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf" title="Not only the memory pool is allocated for all pooled objects, but their non-default constructor is al...">reserve()</a>. The name of the pool will be "unnamed pool". </p>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00236">236</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a3140f243e2a97e037e9c305da3c6612e" name="a3140f243e2a97e037e9c305da3c6612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3140f243e2a97e037e9c305da3c6612e">&#9670;&#160;</a></span>PgeObjectPool() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;<a class="el" href="class_pge_object_pool.html">::PgeObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>poolName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>pooledObjArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not only the memory pool is allocated for all pooled objects, but their non-default constructor is also called with the provided pooled object parameters, or their default constructor if that is available. </p>
<p>It is decided by the user if the pooled object can be properly initialized when the pool is allocated, or further initialization is needed later. In the latter case, either a default constructor must be available or default parameters should be passed to this constructor to be forwarded to the pooled object's non-default constructor to bring the pooled objects to a default state, and later the pooled objects can be properly initialized using the pool's <a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d" title="Finds a free (usable) object in the pool, sets it flag as used and returns it.">create()</a> function which can forward arbitrary parameters to the pooled object's init() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolName</td><td>Name of this pool, for informative purpose. </td></tr>
    <tr><td class="paramname">capacity</td><td>Number of pooled objects to be stored in this pool. Can be changed later with <a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf" title="Not only the memory pool is allocated for all pooled objects, but their non-default constructor is al...">reserve()</a> only if 0 is passed here. </td></tr>
    <tr><td class="paramname">pooledObjArgs</td><td>Arguments to be forwarded to the constructor of the pooled objects. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00260">260</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a7f7a0002a2e21bac3871dad3775bfeff" name="a7f7a0002a2e21bac3871dad3775bfeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7a0002a2e21bac3871dad3775bfeff">&#9670;&#160;</a></span>~PgeObjectPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::~<a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00266">266</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a061d820d66f696a48170edc450b91caf" name="a061d820d66f696a48170edc450b91caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061d820d66f696a48170edc450b91caf">&#9670;&#160;</a></span>PgeObjectPool() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;<a class="el" href="class_pge_object_pool.html">::PgeObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa65856161a0152382aaa33273b4e86fb" name="aa65856161a0152382aaa33273b4e86fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65856161a0152382aaa33273b4e86fb">&#9670;&#160;</a></span>PgeObjectPool() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;<a class="el" href="class_pge_object_pool.html">::PgeObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65588c008acdb3ceff1971447303b1e9" name="a65588c008acdb3ceff1971447303b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65588c008acdb3ceff1971447303b1e9">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives iterator for beginning iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the object pool, to begin iterating over elements in order as they are placed in the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00556">556</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a07467a1127165555602b783605c8fb91" name="a07467a1127165555602b783605c8fb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07467a1127165555602b783605c8fb91">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Total number of allocated objects (<a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>) in this pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00327">327</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a6ca712857635da9dc6d9ed16ff5f8a55" name="a6ca712857635da9dc6d9ed16ff5f8a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca712857635da9dc6d9ed16ff5f8a55">&#9670;&#160;</a></span>capacityBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::capacityBytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Total number of Bytes allocated for the pooled objects (<a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>) in this pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00335">335</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a80516b700d455e1b9e246ae766a68656" name="a80516b700d455e1b9e246ae766a68656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80516b700d455e1b9e246ae766a68656">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives const iterator for beginning iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element of the object pool, to begin iterating over elements in order as they are placed in the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00578">578</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a4f8d935df50d4332d237b7dd0b0845e7" name="a4f8d935df50d4332d237b7dd0b0845e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8d935df50d4332d237b7dd0b0845e7">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives const iterator for ending iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to after the last element of the object pool, to detect finished iterating over elements in order as they are placed in the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00589">589</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="abbbeda64cb71bbaf76fb1051fd95c020" name="abbbeda64cb71bbaf76fb1051fd95c020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbeda64cb71bbaf76fb1051fd95c020">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the free (usable) flag of all objects in the pool, "returns them" into the pool so they can be reused again. </p>
<p>Complexity is O(n) (linear). </p>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00516">516</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="aed4fb79cb2ec825eb2a237f848be733e" name="aed4fb79cb2ec825eb2a237f848be733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4fb79cb2ec825eb2a237f848be733e">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of used objects (<a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>) in this pool, having their used() state true. Basically this is the number of elements in the container, if this pool was an std container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00308">308</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="ae9a51119cc8723ea7cf0f1be60953ff4" name="ae9a51119cc8723ea7cf0f1be60953ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a51119cc8723ea7cf0f1be60953ff4">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives const iterator for beginning reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the last element of the object pool, to begin iterating over elements in reverse order, from the end of the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00622">622</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a14318f7ccdb1a30d2ef66e076be72c8d" name="a14318f7ccdb1a30d2ef66e076be72c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14318f7ccdb1a30d2ef66e076be72c8d">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>pooledObjArgs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a free (usable) object in the pool, sets it flag as used and returns it. </p>
<p>It also forwards arbitrary parameters to the pooled object's init() function. Complexity is O(1) (constant). Note: the returned object stays in the pool but marked as used, and the user can mark it as free by calling <a class="el" href="#a146702259b9f12890b20d71e3a63f10c" title="Resets the free (usable) flag of this object, &quot;returns it&quot; into the pool so it can be reused again.">remove()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>An object ready to be used by caller, or nullptr if all objects within the pool are used already. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00365">365</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a99530f19f172b4b9d27aab5fc956b9bb" name="a99530f19f172b4b9d27aab5fc956b9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99530f19f172b4b9d27aab5fc956b9bb">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives const iterator for ending reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to after the first element of the object pool, to detect finished iterating over elements in reversed order, from the end of the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00633">633</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a00764fa2c24334a7ea2c0730b6b9ab69" name="a00764fa2c24334a7ea2c0730b6b9ab69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00764fa2c24334a7ea2c0730b6b9ab69">&#9670;&#160;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up the allocated contiguous memory pool, capacity becomes zero, name becomes "unnamed pool". </p>
<p>Capacity can be changed again to non-zero value using <a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf" title="Not only the memory pool is allocated for all pooled objects, but their non-default constructor is al...">reserve()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00280">280</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a2b59dae6a04fe53a1c64ff0b623db7b9" name="a2b59dae6a04fe53a1c64ff0b623db7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b59dae6a04fe53a1c64ff0b623db7b9">&#9670;&#160;</a></span>elems() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::elems </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All pooled instances, derived from <a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>, both free and used. Nullptr if the pool is not yet initialized with non-zero size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00528">528</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="acef0760f85a6d31a3a24e9a47b113ed7" name="acef0760f85a6d31a3a24e9a47b113ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef0760f85a6d31a3a24e9a47b113ed7">&#9670;&#160;</a></span>elems() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::elems </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All pooled instances, derived from <a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>, both free and used. Nullptr if the pool is not yet initialized with non-zero size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00537">537</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a1a5ceb71308c79d7324bc1d01d3fef14" name="a1a5ceb71308c79d7324bc1d01d3fef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5ceb71308c79d7324bc1d01d3fef14">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if none of the pooled objects are currently in use, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00343">343</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="ae5f8a3a2a673e3def1a14df87061d873" name="ae5f8a3a2a673e3def1a14df87061d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f8a3a2a673e3def1a14df87061d873">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives iterator for ending iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to after the last element of the object pool, to detect finished iterating over elements in order as they are placed in the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00567">567</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a340a34a5032ed41cad1e47dd16261c2b" name="a340a34a5032ed41cad1e47dd16261c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340a34a5032ed41cad1e47dd16261c2b">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::iterator</td>          <td class="paramname"><span class="paramname"><em>itPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the free (usable) flag of the pooled object pointed by the given iterator, "returns" the object into the pool so it can be reused again. </p>
<p>Equivalent to: remove(*itPos). This function is for convenience, to mimic the <a class="el" href="#a340a34a5032ed41cad1e47dd16261c2b" title="Resets the free (usable) flag of the pooled object pointed by the given iterator, &quot;returns&quot; the objec...">erase()</a> function of std containers, so it is easier to migrate code using an std::container to use <a class="el" href="class_pge_object_pool.html" title="PR00F&#39;s Game Engine object pool for permanently allocating fixed number of game objects.">PgeObjectPool</a>. Complexity is O(1) (constant).</p>
<p>Note: the erased object stays in the pool's contiguous memory, just gets marked as free, so a future call to <a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d" title="Finds a free (usable) object in the pool, sets it flag as used and returns it.">create()</a> might return it again to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itPos</td><td>Iterator to the element to be "erased".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If itPos refers to the last element, then the <a class="el" href="#ae5f8a3a2a673e3def1a14df87061d873" title="Gives iterator for ending iterating over the contiguous memory area of pooled objects,...">end()</a> iterator is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00431">431</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a1db3c9df14274db3eab69ed8b2b36627" name="a1db3c9df14274db3eab69ed8b2b36627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db3c9df14274db3eab69ed8b2b36627">&#9670;&#160;</a></span>getConsole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CConsole &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::getConsole </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00226">226</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a710b5e8484a8520de72e4097ec90b204" name="a710b5e8484a8520de72e4097ec90b204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710b5e8484a8520de72e4097ec90b204">&#9670;&#160;</a></span>getLoggerModuleName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::getLoggerModuleName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00219">219</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a7f4b610874a5f5ca6edd2407f0c19eee" name="a7f4b610874a5f5ca6edd2407f0c19eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4b610874a5f5ca6edd2407f0c19eee">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Name of this pool as it was specified in ctor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00351">351</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a49dcd69f4a802cfbb64f883f19cc455e" name="a49dcd69f4a802cfbb64f883f19cc455e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dcd69f4a802cfbb64f883f19cc455e">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeea7d720e7ac3b82a1ee56222a10e493" name="aeea7d720e7ac3b82a1ee56222a10e493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea7d720e7ac3b82a1ee56222a10e493">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a> &amp;&amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a050a88273d652636562ceac6a008aaab" name="a050a88273d652636562ceac6a008aaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050a88273d652636562ceac6a008aaab">&#9670;&#160;</a></span>rawArrayWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::rawArrayWrapper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The underlying wrapper object giving the iterator functionality. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00545">545</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a2bff05e8f5b65ef8039087dd2f754df9" name="a2bff05e8f5b65ef8039087dd2f754df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bff05e8f5b65ef8039087dd2f754df9">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::reverse_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives iterator for beginning reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the last element of the object pool, to begin iterating over elements in reverse order, from the end of the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00600">600</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a146702259b9f12890b20d71e3a63f10c" name="a146702259b9f12890b20d71e3a63f10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146702259b9f12890b20d71e3a63f10c">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pge_pooled_object.html">PgePooledObject</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the free (usable) flag of this object, "returns it" into the pool so it can be reused again. </p>
<p>Complexity is O(1) (constant).</p>
<p>Note: the removed object stays in the pool's contiguous memory, just gets marked as free, so a future call to <a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d" title="Finds a free (usable) object in the pool, sets it flag as used and returns it.">create()</a> might return it again to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The pooled object to be returned to the pool as free-to-use object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_pge_object_pool_base.html#a6eed9e39d2d505eaee6bafcc4f09f9e1">PgeObjectPoolBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00395">395</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a40c3b174b3aa6bcfc79d90e8890befc3" name="a40c3b174b3aa6bcfc79d90e8890befc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c3b174b3aa6bcfc79d90e8890befc3">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt; T &gt;::reverse_iterator <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives iterator for ending reverse iterating over the contiguous memory area of pooled objects, the same area that <a class="el" href="#a2b59dae6a04fe53a1c64ff0b623db7b9">elems()</a> returns. </p>
<p>Note that iterating over this area iterating over both used and non-used pooled objects, thus you should filter for used pooled objects manually.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to after the first element of the object pool, to detect finished iterating over elements in reversed order, from the end of the contiguous memory pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00611">611</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a4c08a81eb66c2445fb620056e3d312cf" name="a4c08a81eb66c2445fb620056e3d312cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c08a81eb66c2445fb620056e3d312cf">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>poolName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>pooledObjArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not only the memory pool is allocated for all pooled objects, but their non-default constructor is also called with the provided pooled object parameters, or their default constructor if that is available. </p>
<p>Currently works only for zero-capacity pools.</p>
<p>Cannot be used to reduce the capacity of the container. To reduce the capacity of a non-zero capacity container to non-zero, or to increase the capacity, first use <a class="el" href="#a00764fa2c24334a7ea2c0730b6b9ab69" title="Frees up the allocated contiguous memory pool, capacity becomes zero, name becomes &quot;unnamed pool&quot;.">deallocate()</a> to completely free up the used memory area, and then call <a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf" title="Not only the memory pool is allocated for all pooled objects, but their non-default constructor is al...">reserve()</a>.</p>
<p>It is decided by the user if the pooled object can be properly initialized when the pool is allocated, or further initialization is needed later. In the latter case, either a default constructor must be available or default parameters should be passed to this function to be forwarded to the pooled object's non-default constructor to bring the pooled objects to a default state, and later the pooled objects can be properly initialized using the pool's <a class="el" href="#a14318f7ccdb1a30d2ef66e076be72c8d" title="Finds a free (usable) object in the pool, sets it flag as used and returns it.">create()</a> function which can forward arbitrary parameters to the pooled objects init() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolName</td><td>Name of this pool, for informative purpose. </td></tr>
    <tr><td class="paramname">capacity</td><td>Number of pooled objects to be stored in this pool. Can be changed later only with <a class="el" href="#a4c08a81eb66c2445fb620056e3d312cf" title="Not only the memory pool is allocated for all pooled objects, but their non-default constructor is al...">reserve()</a> if 0 is passed here. </td></tr>
    <tr><td class="paramname">pooledObjArgs</td><td>Arguments to be forwarded to the constructor of the pooled objects. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00466">466</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="ab1a1ce9c67982b05a88123703b46d2e4" name="ab1a1ce9c67982b05a88123703b46d2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a1ce9c67982b05a88123703b46d2e4">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventionally std containers have a <a class="el" href="#ab1a1ce9c67982b05a88123703b46d2e4" title="Conventionally std containers have a size() member function returning the number of elements,...">size()</a> member function returning the number of elements, NOT the capacity. </p>
<p>Thus, <a class="el" href="#ab1a1ce9c67982b05a88123703b46d2e4" title="Conventionally std containers have a size() member function returning the number of elements,...">size()</a> is equivalent to <a class="el" href="#aed4fb79cb2ec825eb2a237f848be733e">count()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of used objects (<a class="el" href="class_pge_pooled_object.html" title="Only classes derived from PgePooledObject can be stored in PgeObjectPool.">PgePooledObject</a>) in this pool, having their used() state true. Basically this is the number of elements in the container, if this pool was an std container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00319">319</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a27d271c74ed27f1ee639dc99a15768cd" name="a27d271c74ed27f1ee639dc99a15768cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d271c74ed27f1ee639dc99a15768cd">&#9670;&#160;</a></span>m_capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_capacity {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00640">640</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="abc7380eadf447750c4eaeac72f3b1029" name="abc7380eadf447750c4eaeac72f3b1029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7380eadf447750c4eaeac72f3b1029">&#9670;&#160;</a></span>m_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00640">640</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a0e504cdfaa86b001540208fe049841e9" name="a0e504cdfaa86b001540208fe049841e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e504cdfaa86b001540208fe049841e9">&#9670;&#160;</a></span>m_firstAvailable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pge_pooled_object.html">PgePooledObject</a>* <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_firstAvailable {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00642">642</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a9553dc63d71d83a113ecadf30cb817d9" name="a9553dc63d71d83a113ecadf30cb817d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553dc63d71d83a113ecadf30cb817d9">&#9670;&#160;</a></span>m_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_name {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00639">639</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="a40134cb0ed65549c9f413d5f72cfccc5" name="a40134cb0ed65549c9f413d5f72cfccc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40134cb0ed65549c9f413d5f72cfccc5">&#9670;&#160;</a></span>m_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_pool {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00641">641</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<a id="abcb4a10b9984f4dcf95b6f632dd37d81" name="abcb4a10b9984f4dcf95b6f632dd37d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb4a10b9984f4dcf95b6f632dd37d81">&#9670;&#160;</a></span>m_rawArrayWrapper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbl_iterator_a_p_i_1_1bl_raw_array_wrapper.html">blIteratorAPI::blRawArrayWrapper</a>&lt;T&gt; <a class="el" href="class_pge_object_pool.html">PgeObjectPool</a>&lt; T &gt;::m_rawArrayWrapper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pge_object_pool_8h_source.html#l00643">643</a> of file <a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/__PR00F__/___developing___/projects/PGE/PGE/Memory/<a class="el" href="_pge_object_pool_8h_source.html">PgeObjectPool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_pge_object_pool.html">PgeObjectPool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
