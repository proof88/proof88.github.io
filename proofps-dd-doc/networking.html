<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRooFPS-dd Dev Doc: Networking</title>
<link rel="icon" href="PRooFPS-dd.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="PRooFPS-dd_DoxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="PRooFPS-dd-logo-200x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">PRooFPS-dd Dev Doc<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">PRooFPS-dd Developer Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('networking.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Networking</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#multiplayer_cheating">Cheating in Multiplayer</a>
  </li>
  <li class="level1">
    <a href="#implementation_details">Implementation Details</a>
    <ul>
      <li class="level2">
        <a href="#original_naive_impl">Original Naive Implementation (in v0.1.2)</a>
      </li>
      <li class="level2">
        <a href="#new_tick_based_implementation">New Tick-Based Implementation (from v0.1.3)</a>
      </li>
      <li class="level2">
        <a href="#server_behavior_v014">New Server Behavior (v0.1.3, v0.1.4)</a>
      </li>
      <li class="level2">
        <a href="#client_behavior_v014">New Client Behavior (from v0.1.4)</a>
      </li>
      <li class="level2">
        <a href="#server_behavior_v015">New Server Behavior (v0.1.5)</a>
      </li>
      <li class="level2">
        <a href="#new_behavior_overview">Old and New Behavior Pseudocode</a>
      </li>
      <li class="level2">
        <a href="#packet_rate">Received Packet Rate and Packet Data Rate</a>
        <ul>
          <li class="level3">
            <a href="#server_packet_rate">Server Rx Packet Rate and Packet Data Rate</a>
          </li>
          <li class="level3">
            <a href="#client_packet_rate">Client Rx Packet Rate and Packet Data Rate</a>
          </li>
          <li class="level3">
            <a href="#detailed_packet_rate">Detailed Packet Rate per Function</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#future_plans">Future Improvement Plans</a>
    <ul>
      <li class="level2">
        <a href="#future_plans_server">Server Future Improvement Plans</a>
      </li>
      <li class="level2">
        <a href="#future_plans_client">Client Future Improvement Plans</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#cs_1_6_rates_explained">Counter-Strike 1.6 Rates Explained</a>
  </li>
</ul>
</div>
<div class="textblock"><p>PRooFPS-dd uses the networking subsystem of <a href="https://github.com/proof88/PGE" target="_blank">PGE</a>. <br  />
 This page is basically the continuation of <a href="https://proof88.github.io/pge-doc/networking.html" target="_blank">PGE documentation's Networking page</a>.</p>
<p>From v0.2.7, <b>packet rate calculations are in the <a href="PRooFPS-dd-Packet-Rates.xlsx" target="_blank">PRooFPS-dd-Packet-Rates Excel workbook</a>!</b></p>
<h1><a class="anchor" id="multiplayer_cheating"></a>
Cheating in Multiplayer</h1>
<p>There are many ways to cheat in multiplayer games, and PGE doesn't provide protection against it. <br  />
 However, a good implementation in application level can overcome some forms of cheating. <br  />
 A common approach is to treat the <b>server as the only authorative instance</b> and make clients show only a replication of server state. <br  />
 My game <a href="https://github.com/proof88/PRooFPS-dd" target="_blank">PRooFPS-dd</a> has such client-server model implemented in it.</p>
<p><b>For example: player movement.</b> When a player presses a button to move, it should send a request/command message to the server about the keypress, and the server calculates the actual movement of the player. <br  />
 Then it replies back to the client(s) with the updated position of the player who requested the move, client(s) receive(s) the reply and move(s) the player to the position calculated by the server. <br  />
 Since server takes care of the entire game state, simulate physics, calculate new positions, etc. and replicates game state to clients, it is the only authorative element of the multiplayer game session. <br  />
 This way it is more difficult for clients to do anything from an illegal position, e.g. put themselves out of map bounds intentionally because always the server calculates their position based on client inputs that can be rejected as well.</p>
<p><b>Another example is how the weapons work</b>: when a player pressen a button to shoot, an attack request is sent to the server, and server decides if the player can actually shoot, and if so, it will create a bullet. <br  />
 Since the server keeps track of the available and current weapons for each player, there is no client-side cheat that will allow the player to use arbitrary weapon, also there is no use of modifying the weapon files on client-side since server is using only the server-side files.</p>
<h1><a class="anchor" id="implementation_details"></a>
Implementation Details</h1>
<p>PGE currently does not give explicit support on features like linearly interpolated player positions, it just gives a basic framework to establish connections between clients and the server as described above. <br  />
 However, my game <a href="https://github.com/proof88/PRooFPS-dd" target="_blank">PRooFPS-dd</a> implements some of these features so I'm giving some words about this topic here.</p>
<h2><a class="anchor" id="original_naive_impl"></a>
Original Naive Implementation (in v0.1.2)</h2>
<p>Until <a href="https://github.com/proof88/PRooFPS-dd/releases/tag/v0.1.2-PrivateBeta" target="_blank">PRooFPS-dd v0.1.2 Private Beta</a> <b>my naive approach was to tie input sampling to rendering frame rate and send messages between server and clients as soon as input was detected</b>. <br  />
 As already explained above, in general it is good to select the server as the only authorative instance in the network to provide a basic implementation against cheating. <br  />
 So in my naive approach, when client player pressed a button to move, it did not move the player object, just sent a message to server about the input. <br  />
 The server processed the message and replied back as soon as possible. <br  />
 The updated player positions were in server's response, so on client side I updated the player position upon receiving the response from the server.</p>
<p>This approach looks good if you have high frame rate (e.g. 60 FPS) because client request and server response messages happen very fast, so player movement looks smooth. <br  />
 However, it has multiple downsides as well:</p><ul>
<li>because sending and processing messages is tied to rendering framerate, so player movement speed will heavily rely on the framerate;</li>
<li>the higher the framerate is, the more messages will be sent across computers, that could overload a machine having lower framerate (i.e. packet buffer might get full leading to packet drops).</li>
</ul>
<p>Although the first issue could be solved by calculating new player position based on measured delta time elapsed since last update instead of using constant values, we would still have the second issue. <br  />
 Although physics is not part of this page, in general the variable delta time-based physics is not a good approach anyway because of multiple reasons (e.g. different machines with different delta will calculate different floating point results) so <b>I've implemented fixed delta time approach</b>, more you can read about it:</p><ul>
<li>here: <a href="https://fabiensanglard.net/timer_and_framerate/index.php">https://fabiensanglard.net/timer_and_framerate/index.php</a></li>
<li>and here: <a href="https://gafferongames.com/post/fix_your_timestep/">https://gafferongames.com/post/fix_your_timestep/</a></li>
</ul>
<p>Implementing phyics update with fixed delta time approach helped a lot to introduce the tick-based implementation as described below.</p>
<h2><a class="anchor" id="new_tick_based_implementation"></a>
New Tick-Based Implementation (from v0.1.3)</h2>
<p>Now back to the networking part. <br  />
 From now on the techniques I'm describing are very common in multiplayer games and the terms I'm using are same or very similar as in <a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking" target="_blank">Counter-Strike</a>.</p>
<p>We want framerate-independent player movement, so we have our framerate-independent physics implemented as well, we should tie the input sampling, physics and messaging together, so they will be done with a different rate than the framerate. <br  />
 These things (input sampling, game state update, simulation, physics, messaging) tied together into a single operation called <b>tick</b>. <br  />
 The number of a tick is executed per second is called <b>tickrate</b>.</p>
<p>This is the theory you can read everywhere on the internet. <br  />
 But actually my implementation still does the input sampling part per frame and I'm more carefully explaining this later.</p>
<p>So the <b>essence of moving away from the naive approach is to understand that we execute different part of core game code at different rates</b>:</p><ul>
<li><b>framerate</b>: frequency of frame rendering;</li>
<li><b>tickrate</b>: frequency of ticks i.e. input sampling, game state update and messaging together.</li>
</ul>
<p>Another rule is that <b>framerate &gt;= tickrate</b>. <br  />
 So it is totally ok to have framerate 60 while having tickrate 20. This means that we maximize the number of iterations of main game loop at 60, we target 60 rendered frames every second, and we do only 20 ticks every second. <br  />
 This also eases the requirement of CPU processing power and network bandwidth.</p>
<p>However, it is not that trivial to say that: okay, from now on I'm just sampling and sending input from client to server at 20 Hz because then the player will really feel the delay in the movement. <br  />
 So <b>with my implementation the framerate -&gt; tickrate transition mostly helped reducing network traffic in server -&gt; client direction but not in the other direction</b>.</p>
<p>So in the next sections I explain in more detail how I introduced rate-limiting on client- and server-side.</p>
<h2><a class="anchor" id="server_behavior_v014"></a>
New Server Behavior (v0.1.3, v0.1.4)</h2>
<p>Since physics simulation is done on server-side, introducing <b>tickrate</b> mostly affected the server: using fixed delta approach lead to more reliable player position updates. <br  />
 Sending new player states to clients is done now at tickrate, which in case of 20 Hz introduced a ~66% reduction in network traffic in server -&gt; client direction compared to having the framerate for this rate as in v0.1.2. <br  />
</p>
<p>Even though the <b>bullet travel update traffic</b> from server to client direction was also reduced due to the above, I <b>decided to simply stop</b> sending this kind of traffic. <br  />
 The reason is that even though server simulates bullet travel, clients can also do it on their side. They just simulate the bullet travel, don't care about the hits. <br  />
 So still server informs the clients about the born and removal of a bullet (e.g. if the bullet hit a player or wall), but between bullet born and removal the clients can move the bullet on their own. <br  />
 This also greatly reduced server -&gt; client direction traffic.</p>
<p>Some operations became <b>continuous operations</b>: when enabled, server executes the action in every tick until explicitly stopped. <br  />
 An example for this is player strafe: once player starts strafing, server simulates it at tickrate until player stops strafing. <br  />
 This way we managed to stop clients from storming the server with inputs such as strafe at their framerate. <br  />
 It is important to understand that for such actions we should not only send out message when a button is pressed but also when it is released.</p>
<h2><a class="anchor" id="client_behavior_v014"></a>
New Client Behavior (from v0.1.4)</h2>
<p>With the tickrate introduced, we successfully solved the problem of a slower machine not be able to keep up with processing messages when faster machines are also present in the network. <br  />
 As I already explained above, with my implementation the framerate -&gt; tickrate transition mostly helped reducing network traffic in server -&gt; client direction but not in the other direction.</p>
<p>To reduce traffic in client -&gt; server direction, one idea was the <b>continuous operation</b> that I already explained above, so I'm not explaining it here again. <br  />
 This was used also for the attack (left mouse button) action, once the button is pressed, server simulates that, no need to continuously send it by client.</p>
<p>The basic rule doesn't change:</p><ul>
<li>player is not moved in the moment of detected player input, because player is moved only when server responds with the updated coordinates. <br  />
</li>
<li>player is repositioned on client side when server sends the new coordinates (this was same in the naive approach as well).</li>
</ul>
<p>For other actions such as changing weapon with mouse scroll or keyboard, or reloading the weapon, I <b>introduced rate-limiting with a simple delay</b>: <br  />
 a predefined amount of time MUST elapse before the client can send another same kind of message to the server. <br  />
 Note that there is no use of storming the server with higher rate in tricky ways because the server also calculates with the minimum delays for rate-limiting thus there is no benefit for the player to storm the server.</p>
<p>For other actions like updating weapon angle (client is moving the crosshair by mouse movement), I had to <b>introduce a more sophisticated rate-limiting method</b>:</p><ul>
<li>if the crosshair movement results in changing weapon angle bigger than a specific amount of degree, client sends such update max 10 times per second;</li>
<li>otherwise client sends update max 5 times per second.</li>
</ul>
<p>Details in pseudocode can be checked later on this page in function handleInputAndSendUserCmdMove().</p>
<h2><a class="anchor" id="server_behavior_v015"></a>
New Server Behavior (v0.1.5)</h2>
<p>With low tickrate the physics calculations might not be precise enough. Even with 20 Hz tickrate we <a href="https://github.com/proof88/PRooFPS-dd/issues/234" target="_blank">saw we could not jump on some boxes or fall in between some boxes</a>.</p>
<p>So I decided to introduce the <b>cl_updaterate</b> CVAR that controls how often server should send the updates to clients. <br  />
 It is somehow dependent of the tickrate: in every tick we can either send out updates to clients or postpone to another tick. <br  />
 So if we set high tickrate like 60 Hz, we can have the very precise physics calculations while having cl_updaterate as 20 Hz keeps the required bandwidth low. <br  />
 Rules:</p><ul>
<li><b>0 &lt; cl_updaterate &lt;= tickrate</b>;</li>
<li><b>tickrate % cl_updaterate == 0</b> (clients should receive UPDATED physics results evenly distributed in time).</li>
</ul>
<p>I also introduced another CVAR called <b>physics_rate_min</b>. <br  />
 It allows running multiple physics iterations per tick, so if after all you still set a lower tickrate, you can still have more precise physics. <br  />
</p>
<p>The question in this case: why do we even have tickrate then if physics and server -&gt; client updates can have different rate? <br  />
 The answer is that not only these are handled in a tick on server-side, but other stuff also like updating player- and map item-respawn timers, and in the future some more additions will be in place too. <br  />
 So in general it is good if we have the flexibility of fine-tuning these values.</p>
<h2><a class="anchor" id="new_behavior_overview"></a>
Old and New Behavior Pseudocode</h2>
<p>The following pseudocode shows what functions are invoked by runGame() that are relevant from networking perspective. <br  />
 Server and client instances have the same runGame() code. Some parts are executed only by the server or the client, that is visible from the pseudocode anyway. <br  />
 Some parts were changed between different versions, in those cases I specified the changes with version numbers. <br  />
 In the comments I mention what kind of messages are generated with approximated rates total PKT rate and per-client PKT rate. <br  />
 <b>We are estimating with an intense situation when 8 players are playing the game, and everyone is moving, shooting, and picking up a weapon item at the same time.</b></p>
<p>I also mention <b>AP (action point)</b> wherever I think change should be introduced.</p>
<details >
<summary >
<b>Expand/Collapse Pseudocode</b></summary>
<div class="fragment"><div class="line"><span class="comment">// some constants just for the pkt count calculations in this example</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> nClientsCount = 7;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> nPlayerCount = nClientsCount + 1;  <span class="comment">// +1 is the server itself</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> nBulletsCount =</div>
<div class="line">              nPlayerCount * 6 = 48;             <span class="comment">// assuming all players have 6 travelling bullets in-air at the moment (~worst-case)</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> nMapItemsCount = 25;               <span class="comment">// e.g. 9 pistols + 9 mchguns + 7 medkits</span></div>
<div class="line"> </div>
<div class="line">PGE::runGame() {</div>
<div class="line">  <span class="keywordflow">while</span> ( isGameRunning() ) {</div>
<div class="line">  @FRAMERATE (ideally 60 FPS)</div>
<div class="line">  </div>
<div class="line">      onGameFrameBegin() {</div>
<div class="line">        <a class="code hl_function" href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#a2aab8352e10108cd6049fd24693373bb">proofps_dd::PRooFPSddPGE::onGameFrameBegin</a>()  <span class="comment">// nothing relevant for now</span></div>
<div class="line">      }</div>
<div class="line">    </div>
<div class="line">  <span class="comment">// START transfer PKTs from GNS to PGE level</span></div>
<div class="line">      getNetwork().Update()</div>
<div class="line">  <span class="comment">// END transfer PKTs from GNS to PGE level</span></div>
<div class="line">    </div>
<div class="line">  <span class="comment">// START transfer PKTs from PGE to APP (proofps) level</span></div>
<div class="line">  <span class="comment">// last change in v0.1.4</span></div>
<div class="line">      <span class="keywordflow">while</span> (getNetwork().getServerClientInstance()-&gt;getPacketQueueSize() &gt; 0) {</div>
<div class="line">        onPacketReceived( getNetwork().getServerClientInstance()-&gt;popFrontPacket() ) {       <span class="comment">// invoke application code for all received pkt in m_queuePackets</span></div>
<div class="line">          <a class="code hl_function" href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#ae4521ca0f75d626f392bb663269863e7">proofps_dd::PRooFPSddPGE::onPacketReceived</a>() {</div>
<div class="line">            handleUserConnected();                         <span class="comment">// v0.1.4: might generate a few packets but that is only when a new user has just connected, nothing to do here.</span></div>
<div class="line">            handleUserDisconnected();                      <span class="comment">// no networking</span></div>
<div class="line">            m_config.clientHandleServerInfoFromServer();   <span class="comment">// no networking</span></div>
<div class="line">            handleMapChangeFromServer();                   <span class="comment">// no networking (just low-level network disconnect)</span></div>
<div class="line">            handleUserSetupFromServer();                   <span class="comment">// v0.1.5: might generate a few packets but that is only when a new user is being set up, nothing to do here.</span></div>
<div class="line">            handleUserNameChange();                        <span class="comment">// v0.2.0: neglectable amount of networking to handle user name change</span></div>
<div class="line">            serverHandleUserCmdMoveFromClient();           <span class="comment">// v0.1.4: 14 PKT/s @ 60 FPS server -&gt; client</span></div>
<div class="line">            handleUserUpdateFromServer();                  <span class="comment">// no networking</span></div>
<div class="line">            handleBulletUpdateFromServer();                <span class="comment">// no networking</span></div>
<div class="line">            m_maps.handleMapItemUpdateFromServer();        <span class="comment">// no networking</span></div>
<div class="line">            handleWpnUpdateFromServer();                   <span class="comment">// no networking</span></div>
<div class="line">            handleWpnUpdateCurrentFromServer();            <span class="comment">// no networking</span></div>
<div class="line">            handleDeathNotificationFromServer();           <span class="comment">// no networking</span></div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">  <span class="comment">// END transfer PKTs from PGE to APP (proofps) level</span></div>
<div class="line">  </div>
<div class="line">      onGameRunning() {</div>
<div class="line">        <a class="code hl_function" href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#a0192981f3838d0d125a60e2f476296db">proofps_dd::PRooFPSddPGE::onGameRunning</a>() {</div>
<div class="line">          @FRAMERATE </div>
<div class="line">            serverUpdateWeapons();                   <span class="comment">// v0.1.4: 0 PKT/s @ 60 FPS server -&gt; client (see later in handleUserCmdMoveFromClient() why this is 0)</span></div>
<div class="line">            </div>
<div class="line">            @TICKRATE (ideally 60 Hz)                <span class="comment">// v0.1.3: this was @FRAMERATE in v0.1.2, so all results of v0.1.3 in this block are only 1/3 of v0.1.2.</span></div>
<div class="line">                                                     <span class="comment">// v0.1.5: this is ideally 60 because cl_updaterate controls server-&gt;client updates, physics_rate_min allows more precise physics</span></div>
<div class="line">                <span class="keywordflow">if</span> (getNetwork().isServer()) {                  </div>
<div class="line">                    mainLoopConnectedServerOnlyOneTick() {</div>
<div class="line">                        m_gameMode-&gt;serverCheckAndUpdateWinningConditions(); <span class="comment">// v0.2.4: neglectable server -&gt; client traffic at the moment of game winning conditions becoming true</span></div>
<div class="line">                        </div>
<div class="line">                        @PHYSICS_RATE_MIN (ideally 60 Hz)      <span class="comment">// v0.1.5: physics_rate_min introduced, physics_rate_min &gt;= tickrate</span></div>
<div class="line">                            serverGravity();                       <span class="comment">// v0.2.2: might generate packet about someone dying of falling, but just a few, and in our current scenario nobody dies, so nothing to do here.</span></div>
<div class="line">                            serverPlayerCollisionWithWalls();      <span class="comment">// v0.2.6: might generate packet about someone yelling of high fall, or landed on ground, but just a few, I&#39;m not calculating with these now.</span></div>
<div class="line">                            serverUpdateBullets();                 <span class="comment">// v0.1.4: 160 PKT/s @ 20 Hz tickrate server -&gt; client</span></div>
<div class="line">                                                                   <span class="comment">// v0.1.5: 480 PKT/s @ 60 Hz physics_rate_min server -&gt; client</span></div>
<div class="line">                                                                   <span class="comment">// v0.2.2: same as v0.1.5 with addition of some optional extra packet when someone is killed, which is negligible amount of packets, and</span></div>
<div class="line">                                                                   <span class="comment">//         in our current scenario nobody dies, so essentially no change to v0.1.5.</span></div>
<div class="line">                            serverUpdateExplosions();              <span class="comment">// v0.2.2: some optional extra packet when someone is killed, which is negligible amount of packets, and in our current scenario nobody dies, so</span></div>
<div class="line">                                                                   <span class="comment">//         essentially nothing to do here.</span></div>
<div class="line">                            serverPickupAndRespawnItems();         <span class="comment">// v0.1.4: 180 PKT/s @ 20 Hz tickrate server -&gt; client</span></div>
<div class="line">                                                                   <span class="comment">// v0.1.5: 540 PKT/s @ 60 Hz physics_rate_min server -&gt; client</span></div>
<div class="line">                            updatePlayersOldValues();              <span class="comment">// no networking</span></div>
<div class="line">                        @END PHYSICS_RATE_MIN</div>
<div class="line">                        </div>
<div class="line">                        serverUpdateRespawnTimers();           <span class="comment">// no networking</span></div>
<div class="line">                        </div>
<div class="line">                        @CL_UPDATERATE (ideally 20 Hz)</div>
<div class="line">                            serverSendUserUpdates();           <span class="comment">// v0.1.4, v0.1.5: 160 PKT/s @ 20 Hz server -&gt; client</span></div>
<div class="line">                        @END CL_UPDATERATE</div>
<div class="line">                    </div>
<div class="line">                    }  <span class="comment">// end mainLoopConnectedServerOnlyOneTick()</span></div>
<div class="line">                }  <span class="comment">// end isServer()</span></div>
<div class="line">                <span class="keywordflow">else</span> {             </div>
<div class="line">                    mainLoopConnectedClientOnlyOneTick() { <span class="comment">// v0.1.4: client-side tick got introduced (same value as for server-side)</span></div>
<div class="line">                        @PHYSICS_RATE_MIN (ideally 60 Hz)</div>
<div class="line">                            clientUpdateBullets();             <span class="comment">// v0.1.4: no networking because client-side bullet travel simulation got introduced (without collision-detection)</span></div>
<div class="line">                            clientUpdateExplosions();          <span class="comment">// no networking</span></div>
<div class="line">                        @END PHYSICS_RATE_MIN</div>
<div class="line">                    }</div>
<div class="line">                }  <span class="comment">// end client</span></div>
<div class="line">            @END TICKRATE</div>
<div class="line">          </div>
<div class="line">          @FRAMERATE again</div>
<div class="line">          mainLoopConnectedShared() {</div>
<div class="line">              clientHandleInputWhenConnectedAndSendUserCmdMoveToServer();    <span class="comment">// v0.1.4: 80 PKT/s with 7 clients (8 players) @ 60 FPS client -&gt; server</span></div>
<div class="line">              cameraUpdatePosAndAngle();                                     <span class="comment">// no networking</span></div>
<div class="line">              updatePlayers();                                               <span class="comment">// no networking, invulnerability state is changed by server but that generates only neglectable traffic indirectly</span></div>
<div class="line">              updateVisualsForGameMode();                                    <span class="comment">// server -&gt; client traffic only when current game is restarted, neglectable amount</span></div>
<div class="line">              m_maps.update(m_fps);                                          <span class="comment">// no networking</span></div>
<div class="line">              m_maps.updateVisibilitiesForRenderer();                        <span class="comment">// no networking</span></div>
<div class="line">          }  <span class="comment">// end mainLoopConnectedShared</span></div>
<div class="line">        }  <span class="comment">// end proofps_dd::PRooFPSddPGE::onGameRunning()</span></div>
<div class="line">      }  <span class="comment">// end onGameRunning()</span></div>
<div class="line">    </div>
<div class="line">      RenderScene();</div>
<div class="line">      frameLimit();    </div>
<div class="line">  </div>
<div class="line">  @END FRAMERATE</div>
<div class="line">  }  <span class="comment">// end while ( isGameRunning() )</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassproofps__dd_1_1_p_roo_f_p_sdd_p_g_e_html_a0192981f3838d0d125a60e2f476296db"><div class="ttname"><a href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#a0192981f3838d0d125a60e2f476296db">proofps_dd::PRooFPSddPGE::onGameRunning</a></div><div class="ttdeci">virtual void onGameRunning() override</div><div class="ttdoc">Game logic for each frame.</div><div class="ttdef"><b>Definition</b> <a href="_p_roo_f_p_s-dd-_p_g_e_8cpp_source.html#l00291">PRooFPS-dd-PGE.cpp:291</a></div></div>
<div class="ttc" id="aclassproofps__dd_1_1_p_roo_f_p_sdd_p_g_e_html_a2aab8352e10108cd6049fd24693373bb"><div class="ttname"><a href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#a2aab8352e10108cd6049fd24693373bb">proofps_dd::PRooFPSddPGE::onGameFrameBegin</a></div><div class="ttdeci">virtual void onGameFrameBegin() override</div><div class="ttdoc">Game logic right before the engine would do anything.</div><div class="ttdef"><b>Definition</b> <a href="_p_roo_f_p_s-dd-_p_g_e_8cpp_source.html#l00267">PRooFPS-dd-PGE.cpp:267</a></div></div>
<div class="ttc" id="aclassproofps__dd_1_1_p_roo_f_p_sdd_p_g_e_html_ae4521ca0f75d626f392bb663269863e7"><div class="ttname"><a href="classproofps__dd_1_1_p_roo_f_p_sdd_p_g_e.html#ae4521ca0f75d626f392bb663269863e7">proofps_dd::PRooFPSddPGE::onPacketReceived</a></div><div class="ttdeci">virtual bool onPacketReceived(const pge_network::PgePacket &amp;pkt) override</div><div class="ttdoc">Called when a new network packet is received.</div><div class="ttdef"><b>Definition</b> <a href="_p_roo_f_p_s-dd-_p_g_e_8cpp_source.html#l00407">PRooFPS-dd-PGE.cpp:407</a></div></div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="packet_rate"></a>
Received Packet Rate and Packet Data Rate</h2>
<p><b>Rx Packet Rate</b> shows the number of received packets processed per second by server or client. <br  />
 I also calculate the estimated <b>Rx Packet Data Rate</b> based on the received packet rate and size of packets. <br  />
 The improvements through versions are very decent and were really needed to solve <a href="https://github.com/proof88/PRooFPS-dd/issues/184" target="_blank">the packet congestion issue</a>.</p>
<h3><a class="anchor" id="server_packet_rate"></a>
Server Rx Packet Rate and Packet Data Rate</h3>
<p>In this section we talk about <b>client -&gt; server</b> traffic.</p>
<p>Considering 8 players:</p><ul>
<li><b>v0.1.2:</b><ul>
<li><b>480 PKT/s with 7 clients (8 players) @ 60 FPS</b> as per handleInputAndSendUserCmdMove(), <br  />
</li>
<li><b>120 PKT/s with 1 client (2 players) @ 60 FPS</b> (1 will be by the server by injection though). <br  />
</li>
<li>Since a PgePacket size was fix 268 Bytes, this lead to: <br  />
 <b>128 640 Byte/s Packet Data Rate</b> on server-side with 8 players. <br  />
</li>
</ul>
</li>
<li><b>v0.1.3:</b><ul>
<li>same as v0.1.2 since clients are still storming the server with same pkt rate and pkt size;</li>
</ul>
</li>
<li><b>v0.1.4:</b><ul>
<li><b>128 PKT/s with 7 clients (8 players) @ 60 FPS</b> as per handleInputAndSendUserCmdMove(), <br  />
</li>
<li><b>32 PKT/s with 1 client (2 players) @ 60 FPS</b> (1 will be by the server by injection though). <br  />
 This is only the 27% of the packet rate of v0.1.3! <br  />
</li>
<li>Since <b>variable packet size</b> was introduced also in this version in PGE, and MsgUserCmdFromClient is 16 Bytes, PgePacket overhead 15 Bytes so total PgePacket size is 31 Bytes, this leads to: <br  />
 31 * 128 = <b>3 968 Byte/s Packet Data Rate</b> on server-side with 8 players, which is only the 3% of v0.1.3!</li>
</ul>
</li>
<li><b>v0.1.6.1, v0.2.0, v0.2.1, v0.2.2, v0.2.3, v0.2.4, v0.2.5, v0.2.6:</b><ul>
<li>same as v0.1.4, the new features did not affect network traffic in client -&gt; server direction.</li>
</ul>
</li>
<li><b>v0.2.7 and onwards:</b><ul>
<li>only the <a href="PRooFPS-dd-Packet-Rates.xlsx" target="_blank">PRooFPS-dd-Packet-Rates Excel workbook</a> is kept updated.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="client_packet_rate"></a>
Client Rx Packet Rate and Packet Data Rate</h3>
<p>In this section we talk about <b>server -&gt; client</b> traffic.</p>
<p>Considering 8 players, the results are to a single client from the server:</p><ul>
<li><b>v0.1.2:</b><ul>
<li><b>4 320 PKT/s @ 60 FPS</b>, with 4320 * 268 = <b>1 157 760 Byte/s Packet Data Rate</b>:<ul>
<li>420 PKT/s @ 60 FPS as per handleUserCmdMoveFromClient();</li>
<li>2880 PKT/s @ 60 FPS as per serverUpdateBullets();</li>
<li>540 PKT/s @ 60 FPS as per serverPickupAndRespawnItems();</li>
<li>480 PKT/s @ 60 FPS as per serverSendUserUpdates().</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.1.3:</b><ul>
<li><b>1 720 PKT/s @ 60 FPS &amp; 20 Hz</b>, with 1720 * 268 = <b>460 960 Byte/s Packet Data Rate</b> (which is only the 40% of v0.1.2 rates):<ul>
<li>420 PKT/s @ 60 FPS as per handleUserCmdMoveFromClient();</li>
<li>960 PKT/s @ 20 Hz as per serverUpdateBullets();</li>
<li>180 PKT/s @ 20 Hz as per serverPickupAndRespawnItems();</li>
<li>160 PKT/s @ 20 Hz as per serverSendUserUpdates().</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.1.4:</b><ul>
<li><b>514 PKT/s @ 60 FPS &amp; 20 Hz</b> (this is only the 12% of v0.1.2 rate!), with 1106 + 11360 + 5500 + 8800 = <b>27 082 Byte/s Packet Data Rate</b> (which is only the 2% of v0.1.2 data rate!) <br  />
 (if you set tickrate to 60 Hz in this version, it will be 1518 PKT/s that is still only the 35% of v0.1.2 rate, and 1106 + 34080 + 16500 + 26400 = 78 402 Byte/s Packet Data Rate that is still only the 7% of v0.1.2 data rate!).<ul>
<li>14 PKT/s @ 60 FPS as per handleUserCmdMoveFromClient(), with 14 * 79 = 1106 Byte/s Packet Data Rate (size of MsgCurrentWpnUpdateFromServer is 64 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>0 PKT/s @ 60 FPS as per serverUpdateWeapons() (that was not relevant in previous versions), now it is still not relevant because the rate it could produce is less than handleUserCmdMoveFromClient()'s rate in case of weapon changing, and firing is impossible during weapon changing so handleUserCmdMoveFromClient() is considered in the calculation only. I'm still showing this in the list with 0 rate though. <br  />
</li>
<li>160 PKT/s @ 20 Hz as per serverUpdateBullets(), with 160 * 71 = 11360 Byte/s Packet Data Rate (size of MsgBulletUpdateFromServer is 56 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>180 PKT/s @ 20 Hz as per serverPickupAndRespawnItems(), with 20 * 91 + (8*20) * 23 = 5500 Byte/s Packet Data Rate (size of MsgWpnUpdateFromServer is 76 Bytes, size of MsgMapItemUpdateFromServer is 8 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>160 PKT/s @ 20 Hz as per serverSendUserUpdates(), with 160 * 55 = 8800 Byte/s Packet Data Rate (size of MsgUserUpdateFromServer is 40 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.1.5:</b><ul>
<li><b>1194 PKT/s @ 60 FPS &amp; 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min</b> (this is only the 28% of v0.1.2 rate!), with 1106 + 34080 + 16500 + 8800 = <b>60 802 Byte/s Packet Data Rate</b> (which is only the 5% of v0.1.2 data rate!).<ul>
<li>14 PKT/s @ 60 FPS as per handleUserCmdMoveFromClient(), with 14 * 79 = 1106 Byte/s Packet Data Rate (size of MsgCurrentWpnUpdateFromServer is 64 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>0 PKT/s @ 60 FPS as per serverUpdateWeapons() (that was not relevant in previous versions), now it is still not relevant because the rate it could produce is less than handleUserCmdMoveFromClient()'s rate in case of weapon changing, and firing is impossible during weapon changing so handleUserCmdMoveFromClient() is considered in the calculation only. I'm still showing this in the list with 0 rate though. <br  />
</li>
<li>480 PKT/s @ 60 Hz as per serverUpdateBullets(), with 480 * 71 = 34080 Byte/s Packet Data Rate (size of MsgBulletUpdateFromServer is 56 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>540 PKT/s @ 60 Hz as per serverPickupAndRespawnItems(), with 60 * 91 + (8*60) * 23 = 16500 Byte/s Packet Data Rate (size of MsgWpnUpdateFromServer is 76 Bytes, size of MsgMapItemUpdateFromServer is 8 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>160 PKT/s @ 20 Hz as per serverSendUserUpdates(), with 160 * 55 = 8800 Byte/s Packet Data Rate (size of MsgUserUpdateFromServer is 40 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.1.6.1:</b><ul>
<li>same as v0.1.5, the new features did not affect network traffic.</li>
</ul>
</li>
<li><b>v0.2.0.0:</b><ul>
<li><b>slight increase in packet data rate</b> due to size of MsgBulletUpdateFromServer increased from 56 Bytes to 68 Bytes:</li>
<li><b>1194 PKT/s @ 60 FPS &amp; 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min</b> (this is only the 28% of v0.1.2 rate!), with 1106 + 39840 + 16500 + 8800 = <b>66 562 Byte/s Packet Data Rate</b> (which is only the 6% of v0.1.2 data rate!).<ul>
<li>480 PKT/s @ 60 Hz as per serverUpdateBullets(), with 480 * 83 = 39840 Byte/s Packet Data Rate (size of MsgBulletUpdateFromServer is 68 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.2.2.0:</b><ul>
<li><b>slight increase in packet data rate</b> due to size of MsgUserUpdateFromServer increased from 40 Bytes to 48 Bytes:</li>
<li><b>1194 PKT/s @ 60 FPS &amp; 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min</b> (this is only the 28% of v0.1.2 rate!), with 1106 + 39840 + 16500 + 10080 = <b>67 842 Byte/s Packet Data Rate</b> (which is only the 6% of v0.1.2 data rate!).<ul>
<li>160 PKT/s @ 20 Hz as per serverSendUserUpdates(), with 160 * 63 = 10 080 Byte/s Packet Data Rate (size of MsgUserUpdateFromServer is 48 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.2.3.0:</b><ul>
<li><b>slight increase in both packet rate and packet data rate</b> due to size of MsgCurrentWpnUpdateFromServer increased from 64 Bytes to 68 Bytes, and serverUpdateWeapons() might also send it out; <br  />
 also size of MsgUserUpdateFromServer increased from 48 Bytes to 52 Bytes (added invulnerability flag):</li>
<li><b>1208 PKT/s @ 60 FPS &amp; 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min</b> (this is only the 28% of v0.1.2 rate!), with 1162 + 1162 + 39840 + 16500 + 10720 = <b>69 384 Byte/s Packet Data Rate</b> (which is only the 6% of v0.1.2 data rate!).<ul>
<li>14 PKT/s @ 60 FPS (unchanged) as per handleUserCmdMoveFromClient(), with 14 * 83 = 1162 Byte/s Packet Data Rate (size of MsgCurrentWpnUpdateFromServer increased to 68 Bytes, PgePacket overhead is 15 Bytes);</li>
<li>~14 PKT/s @ 60 FPS (extra in this version) as per serverUpdateWeapons(), with 14 * 83 = 1162 Byte/s Packet Data Rate: <br  />
 even though in previous versions we always rated it to 0 due to weapon changing, here in this version we are calculating with continuous firing-induced weapon changes, since it is now reflecting weapon state changes to clients and we want to have calculations ready with that in mind (even though shooting and weapon changing cannot happen at the same time).</li>
<li>160 PKT/s @ 20 Hz (unchanged) as per serverSendUserUpdates(), with 160 * 67 = 10 720 Byte/s Packet Data Rate (size of MsgUserUpdateFromServer is 52 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.2.4, v0.2.5:</b><ul>
<li>same as v0.2.3, the new features did not affect network traffic.</li>
</ul>
</li>
<li><b>v0.2.6:</b><ul>
<li>there is just slight additional network traffic, due to adding MsgPlayerEventFromServer that is sent occasionally (landed on ground or falling high yell or jumppad activation) to clients. <br  />
 I'm not calculating with this now because frequency is relatively low compared to other messages I'm calculating with.</li>
<li><b>1208 PKT/s @ 60 FPS &amp; 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min</b> (this is only the 28% of v0.1.2 rate!), with 1162 + 1162 + 39840 + 16980 + 10720 = <b>69 864 Byte/s Packet Data Rate</b> (which is only the 7% of v0.1.2 data rate!):<ul>
<li>size of MsgWpnUpdateFromServer increased from 76 to 84 Bytes, thus serverPickupAndRespawnItems() generates slightly bigger traffic:<ul>
<li>540 PKT/s @ 60 Hz as per serverPickupAndRespawnItems(), with 60 * 99 + (8*60) * 23 = 16980 Byte/s Packet Data Rate (size of MsgWpnUpdateFromServer is 84 Bytes, size of MsgMapItemUpdateFromServer is 8 Bytes, PgePacket overhead is 15 Bytes).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>v0.2.7 and onwards:</b><ul>
<li>only the <a href="PRooFPS-dd-Packet-Rates.xlsx" target="_blank">PRooFPS-dd-Packet-Rates Excel workbook</a> is kept updated.</li>
</ul>
</li>
</ul>
<p>Considering 8 players, the results to ALL clients from the server (because above shows results to 1 client from the server): <br  />
 just multiply above results by 7 (server sending to itself avoids GNS level thus we multiply by nClientsCount instead of nPlayersCount):</p><ul>
<li><b>v0.1.2:</b> 30 240 PKT/s with 8 104 320 Byte/s Outgoing Packet Data Rate Total;</li>
<li><b>v0.1.4:</b> 3 598 PKT/s with 189 574 Byte/s Outgoing Packet Data Rate Total (88% decrease in packet rate and 98% decrease in packet data rate) @ 20 Hz Tickrate <br  />
 (10 626 PKT/s with 548 814 Byte/s Outgoing Packet Data Rate Total that is 65% decrease in packet rate and 93% decrease in packet data rate @ 60 Hz Tickrate);</li>
<li><b>v0.1.5:</b> 8 358 PKT/s with 425 614 Byte/s Outgoing Packet Data Rate Total (72% decrease in packet rate and 95% decrease in packet data rate compared to v0.1.2) @ 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min;</li>
<li><b>v0.1.6.1:</b> same as with v0.1.5;</li>
<li><b>v0.2.0.0:</b> 8 358 PKT/s with 465 934 Byte/s Outgoing Packet Data Rate Total (72% decrease in packet rate and 95% decrease in packet data rate compared to v0.1.2) @ 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min;</li>
<li><b>v0.2.2.0:</b> 8 358 PKT/s with 474 894 Byte/s Outgoing Packet Data Rate Total (72% decrease in packet rate and 95% decrease in packet data rate compared to v0.1.2) @ 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min;</li>
<li><b>v0.2.3.0:</b> 8 456 PKT/s with 488 012 Byte/s Outgoing Packet Data Rate Total (72% decrease in packet rate and 94% decrease in packet data rate compared to v0.1.2) @ 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min;</li>
<li><b>v0.2.4, v0.2.5:</b> same as with v0.2.3;</li>
<li><b>v0.2.6:</b> 8 456 PKT/s with 491 372 Byte/s Outgoing Packet Data Rate Total (72% decrease in packet rate and 94% decrease in packet data rate compared to v0.1.2) @ 60 Hz Tickrate &amp; 20 Hz cl_updaterate &amp; 60 Hz physics_rate_min;</li>
<li><b>v0.2.7 and onwards:</b> only the <a href="PRooFPS-dd-Packet-Rates.xlsx" target="_blank">PRooFPS-dd-Packet-Rates Excel workbook</a> is kept updated.</li>
</ul>
<h3><a class="anchor" id="detailed_packet_rate"></a>
Detailed Packet Rate per Function</h3>
<p>The detailed explanation of the packet rates of each function is below:</p>
<details >
<summary >
<b>Expand/Collapse Pseudocode</b></summary>
<div class="fragment"><div class="line">getNetwork().Update() {</div>
<div class="line"><span class="comment">// no changes since v0.1.2</span></div>
<div class="line">  <span class="keywordflow">while</span> (</div>
<div class="line">    m_pServerClient-&gt;pollIncomingMessages() {</div>
<div class="line">      ISteamNetworkingMessage* pIncomingGnsMsg[const nIncomingMsgArraySize = 10];</div>
<div class="line">      const int numGnsMsgs = receiveMessages(pIncomingGnsMsg, nIncomingMsgArraySize);  <span class="comment">// so we read max 10 PKTs from GNS each frame (max. 600 PKT/s @ 60 FPS)</span></div>
<div class="line">      </div>
<div class="line">      for (int i = 0; i &lt; numGnsMsgs; i++) {</div>
<div class="line">        pge_network::PgePacket pkt;</div>
<div class="line">        memcpy(&amp;pkt, (pIncomingGnsMsg[i])-&gt;m_pData, nActualPktSize);                   <span class="comment">// !!! expensive deep copy !!!</span></div>
<div class="line">        (pIncomingGnsMsg[i])-&gt;Release();                                               <span class="comment">// cheap unlink from linked list</span></div>
<div class="line">        m_queuePackets.push_back(pktAsConst);                                          <span class="comment">// !!! expensive deep copy !!!</span></div>
<div class="line">                                                                                       <span class="comment">// AP-99: find a way to link these into m_queuePackets maybe?</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  ) {}  <span class="comment">// end while</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">handleUserCmdMoveFromClient() {</div>
<div class="line">    <span class="comment">// Process inputs from clients.</span></div>
<div class="line">    <span class="comment">// Here we dont discuss how clients can flood the server, that is discussed in handleInputAndSendUserCmdMove().</span></div>
<div class="line">    <span class="comment">// Instead, here we discuss what packets with what rate are generated here as response to clients!</span></div>
<div class="line">    <span class="comment">// Worst case we need to multiply everything by nClientsCount and by their send rate:</span></div>
<div class="line">    <span class="comment">// - in v0.1.2 most input were sent at their frame rate.</span></div>
<div class="line">    <span class="comment">// - in v0.1.3 things were similar.</span></div>
<div class="line">    <span class="comment">// In v0.1.3, server polled max nIncomingMsgArraySize (= 10) packets / frame: 10 * 60 = 600 PKT/s @ 60 FPS poll, so</span></div>
<div class="line">    <span class="comment">// with nPlayerCount = 8 players, each player sending a message in each frame, that is 8 * 60 = 480 PKT/s @ 60 FPS, so</span></div>
<div class="line">    <span class="comment">// server COULD really poll nPlayerCount number of such message in each frame.</span></div>
<div class="line">    <span class="comment">// That leads to the following OUTGOING packet rate from server to clients in this function:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  - in v0.1.3 it might had generated nClientsCount number of MsgCurrentWpnUpdateFromServer, so:</span></div>
<div class="line">    <span class="comment">//    7*7 * 60 = 2940 PKT/s @ 60 FPS total outgoing,</span></div>
<div class="line">    <span class="comment">//    that is 420 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">//    This is true only if clients are constantly changing their current weapons in each frame, which unfortunately can happen if everybody is</span></div>
<div class="line">    <span class="comment">//    using the mouse scroll continuously just for fun and that is detected at framerate at client-side, triggering message to server every frame.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//    In v0.1.4 we introduced a 500ms minimum elapse time for weapon change, so max 2 weapon changes are allowed per second.</span></div>
<div class="line">    <span class="comment">//    This changes the calculation to:</span></div>
<div class="line">    <span class="comment">//    7*7 * 2 = 98 PKT/s @ 60 FPS total outgoing,</span></div>
<div class="line">    <span class="comment">//    that is 7*2 = 14 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//    To clarify: even though we said the situation is everyone is shooting, here we will select the weapon change calculation because it generates more</span></div>
<div class="line">    <span class="comment">//    traffic than continuous shooting. Because when shooting is continuous, this function makes traffic as described below, and it is LESS than</span></div>
<div class="line">    <span class="comment">//    the weapon changing traffic described above.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  - before v0.1.4:</span></div>
<div class="line">    <span class="comment">//    might generate 1 MsgWpnUpdateFromServer for updating bullet count for firing (wpn-&gt;pullTrigger() returns true), so:</span></div>
<div class="line">    <span class="comment">//    1*7 * 60 = 420 PKT/s @ 60 FPS outgoing total,</span></div>
<div class="line">    <span class="comment">//    that is 60 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">//    This is true only if a shot is actually fired in every frame, that actually cannot happen due to the fastest firing weapon is mchgun with</span></div>
<div class="line">    <span class="comment">//    150 msec firing_cooldown, effectively limiting the value to:</span></div>
<div class="line">    <span class="comment">//    1*7 * 6.7 = ~ 49 PKT/s @ 60 FPS outgoing total,</span></div>
<div class="line">    <span class="comment">//    that is ~6.7 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//    v0.1.4: this logic has been moved to serverUpdateWeapons() because firing became a continuous operation.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  - above cannot really be mixed with each other since after changing weapon, there is a m_nWeaponActionMinimumWaitMillisecondsAfterSwitch = 1000 required</span></div>
<div class="line">    <span class="comment">//    timeout before a bullet can be fired.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">serverUpdateWeapons() {</div>
<div class="line">    <span class="comment">// This block is at framerate since v0.1.4, previously it was in server tick.</span></div>
<div class="line">    <span class="comment">// The reason of moving this to framerate is that in v0.1.4 attack/mouse left button became a continuous operation, thus player attacking state</span></div>
<div class="line">    <span class="comment">// is saved on server-side until explicitly said so, and need to invoke wpn-&gt;pullTrigger() as often as possible which cannot be done simply with</span></div>
<div class="line">    <span class="comment">// tickrate. A fast-firing weapon such as the mchun with ~6 shots/second need to be &quot;triggered&quot; more frequently than tickrate, otherwise some</span></div>
<div class="line">    <span class="comment">// bullets will be fired some millisecs later than expected.</span></div>
<div class="line">    <span class="comment">// And anyway even with a pistol it is not acceptable if client pulls trigger at time point T but server actually creates bullet at T + (50-16.6) msec</span></div>
<div class="line">    <span class="comment">// later (worst case).</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// v0.1.4: Might generate 1 MsgWpnUpdateFromServer for updating bullet count for firing (wpn-&gt;pullTrigger() returns true), so:</span></div>
<div class="line">    <span class="comment">// 1*7 * 60 = 420 PKT/s @ 60 FPS outgoing total,</span></div>
<div class="line">    <span class="comment">// that is 60 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">// This is true only if a shot is actually fired in every frame, that actually cannot happen due to the fastest firing weapon is mchgun with</span></div>
<div class="line">    <span class="comment">// 150 msec firing_cooldown, effectively limiting the value to:</span></div>
<div class="line">    <span class="comment">// 1*7 * 6.7 = ~ 49 PKT/s @ 60 FPS outgoing total,</span></div>
<div class="line">    <span class="comment">// that is ~6.7 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Might send nClientsCount number of MsgWpnUpdateFromServer, currently only for reloading a weapon:</span></div>
<div class="line">    <span class="comment">// max. 7 * 60 = 420 PKT/s @ 60 FPS total outgoing to clients,</span></div>
<div class="line">    <span class="comment">// that is max 1 * 60 = 60 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    <span class="comment">// However reloading is also rate-limited by reload_time weapon cvar (reload_time), that is 1500 msecs currently for both pistol and mchgun.</span></div>
<div class="line">    <span class="comment">// Thus this is not considered yet.</span></div>
<div class="line">    <span class="comment">// In v0.2.0.0 Bazooka, the first per-bullet-reloadable weapon has become available, but its bullet reload time is 1000 msecs, thus we can still</span></div>
<div class="line">    <span class="comment">// leave this out of calculations.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// From v0.2.3.0, MsgCurrentWpnUpdateFromServer can be also sent out by this function if the current state of the weapon changes.  </span></div>
<div class="line">    <span class="comment">// Remember, unlike MsgWpnUpdateFromServer, this MsgCurrentWpnUpdateFromServer is sent out to ALL clients. </span></div>
<div class="line">    <span class="comment">// This way server reflects any player&#39;s state of their current weapon to all clients.  </span></div>
<div class="line">    <span class="comment">// At this point we have only IDLE, RELOADING and SHOOTING states, no specific state for changing weapon. When weapon is changed, same message type is still sent out by handleUserCmdMoveFromClient().  </span></div>
<div class="line">    <span class="comment">// If weapon is changed, state can only be IDLE for the period of weapon change duration, thus weapon change and state change induced messages are not sent out overlapped.  </span></div>
<div class="line">    <span class="comment">// Even though we calculate rate for handleUserCmdMoveFromClient() for weapon change, we are now calculating with shooting-induced weapon state changes for serverUpdateWeapons() just for</span></div>
<div class="line">    <span class="comment">// seeing how many packets can be generated in this situation.  </span></div>
<div class="line">    <span class="comment">// We don&#39;t need to take RELOADING into account as it is always a time-consuming process, we should calculate with firing: 1 shot will lead to IDLE-SHOOTING-IDLE state changes.  </span></div>
<div class="line">    <span class="comment">// As currently machine gun is the fastest shooter with 150 msec firing_cooldown, this leads to 6.7 shots/second i.e. 13.4 state changes per second: </span></div>
<div class="line">    <span class="comment">// 1*7 * 13.4 = ~ 98 PKT/s @ 60 FPS outgoing total,</span></div>
<div class="line">    <span class="comment">// that is ~14 PKT/s @ 60 FPS to a single client.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Note that if a reload_time is less than or close to tickrate, it won&#39;t be properly updated as intended. That is also a reason why this function</span></div>
<div class="line">    <span class="comment">// is not in the server tick anymore.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">serverUpdateBullets() {</div>
<div class="line">    <span class="comment">// Until v0.1.3 server continuously sent all bullet movements to clients.     </span></div>
<div class="line">    <span class="comment">// v0.1.3 sends nBulletsCount number of MsgBulletUpdateFromServer to ALL clients:</span></div>
<div class="line">    <span class="comment">// 48*7 PKT * 20 Hz = 6720 PKT/s @ 20 Hz total outgoing,</span></div>
<div class="line">    <span class="comment">// that is 960 PKT/s @ 20 Hz to a single client.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// But from v0.1.4 it just sends msg about new bullet or bullet delete, clients also simulate the bullet travel so it doesn&#39;t eat network traffic.</span></div>
<div class="line">    <span class="comment">// v0.1.4 sends nPlayerCount number of MsgBulletUpdateFromServer to ALL clients in case everyone is shooting a new bullet in each tick, or</span></div>
<div class="line">    <span class="comment">// in case 1-1 bullet of each player hits something so needs to be deleted. Traffic is reduced to:</span></div>
<div class="line">    <span class="comment">// 8*7 PKT * 20 Hz = 1120 PKT/s @ 20 Hz total outgoing,</span></div>
<div class="line">    <span class="comment">// that is 160 PKT/s @ 20 Hz to a single client.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">serverPickupAndRespawnItems() {</div>
<div class="line">    <span class="comment">// might send nClientsCount number of MsgWpnUpdateFromServer and (nMapItemsCount * nClientsCount) number of MsgMapItemUpdateFromServer:</span></div>
<div class="line">    <span class="comment">// max. (7 + 25*7) PKT * 20 Hz = 3640 PKT/s @ 20 Hz total outgoing,</span></div>
<div class="line">    <span class="comment">// that is 26 PKT * 20 Hz = 520 PKT/s @ 20 Hz to a single client.</span></div>
<div class="line">    <span class="comment">// However very unlikely that all players are picking up an item in every tick AND every item is respawning also in every tick.</span></div>
<div class="line">    <span class="comment">// The realistic is that per tick as many items are respawning as the number of players since those players could pick up only 1 item at a time.</span></div>
<div class="line">    <span class="comment">// So I would rather calculate with: might send nClientsCount number of MsgWpnUpdateFromServer and nPlayerCount number of MsgMapItemUpdateFromServer:</span></div>
<div class="line">    <span class="comment">// (7 + 8) PKT * 20 Hz = 300 PKT/s @ 20 Hz total outgoing,</span></div>
<div class="line">    <span class="comment">// that is (1 + 8) PKT * 20 Hz = 180 PKT/s @ 20 Hz to a single client.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">serverSendUserUpdates() {</div>
<div class="line">    <span class="comment">// max. nPlayerCount number of MsgUserUpdateFromServer to ALL clients (and to server by injection though):</span></div>
<div class="line">    <span class="comment">// 8*7 PKT * 20 Hz = 1120 PKT/s @ 20 Hz total outgoing,</span></div>
<div class="line">    <span class="comment">// that is 8 PKT * 20 Hz = 160 PKT/s @ 20 Hz to a single client.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">handleInputAndSendUserCmdMove() {</div>
<div class="line">    <span class="comment">// Here we talk about how clients can flood the server.</span></div>
<div class="line">    <span class="comment">// Might send 1 MsgUserCmdFromClient to server in case of input.</span></div>
<div class="line">    <span class="comment">// We dont want to storm the server at FPS rate, so here we introduced ways of rate-limiting client input in later versions.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// v0.1.2: didnt do any rate-limiting. Thus with clients constantly generating input, that means nPlayerCount number of MsgUserCmdFromClient:</span></div>
<div class="line">    <span class="comment">// 1*8 * 60 = 480 PKT/s @ 60 FPS total incoming to server (1 will be by the server by injection though),</span></div>
<div class="line">    <span class="comment">// that is 1*60 = 60 PKT/s @ 60 FPS from a single client.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// v0.1.3: introduced the concept &quot;continuous operation&quot;, it means: once you set the action, server keeps doing the action until explicitly said to stop.</span></div>
<div class="line">    <span class="comment">// This is very handy from physics simulation perspective as well since server can simulate something precisely without continuously telling it to do so,</span></div>
<div class="line">    <span class="comment">// and this also greatly decreases client -&gt; server traffic.</span></div>
<div class="line">    <span class="comment">// Strafe has been changed to be such continuous operation.</span></div>
<div class="line">    <span class="comment">// But due to a bug the traffic was not decreased.</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// v0.1.4: strafe pkt traffic got fixed so now really 1 PKT is sent per strafe-state-change!</span></div>
<div class="line">    <span class="comment">// v0.1.6: crouching added as new action as continuous-op like strafe. However, the packet size did not change and we dont need to consider higher frequency</span></div>
<div class="line">    <span class="comment">//         than what we already considered with strafing, calculations don&#39;t need to be changed.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Some operations don&#39;t need to be set as continuous operation because they are triggered by keyup-keydown pairs (controlled by getKeyboard().isKeyPressedOnce())</span></div>
<div class="line">    <span class="comment">// thus cannot flood the server by simply pressing the relevant buttons continuously: jump, toggleRunWalk, requestReload, weapon switch.</span></div>
<div class="line">    <span class="comment">// Before v0.1.4: so these are rate-limited at client-side implicitly by the fact that there is a physical limit how many times a player can do key-down-key-up</span></div>
<div class="line">    <span class="comment">// series within a second, for now we can say worst-case 5/sec, that is so low I&#39;m not considering now.</span></div>
<div class="line">    <span class="comment">// However, weapon changing by keyboard, currently for switching between pistol and mchgun back-and-forth, could reach worst-case 15 PKT/sec in v0.1.3.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// v0.1.4: a 500 millisecs time elapse is also required between wpn change keystrokes thus I believe switching back-and-forth is now worst-case 5 PKT/sec.</span></div>
<div class="line">    <span class="comment">//         Also introduced rate-limit for weapon changing by mouse scrolling which was still at framerate in v0.1.3.</span></div>
<div class="line">    <span class="comment">//         Wpn change rate by mouse scroll or keyboard are measured together so they are worst-case 5 PKT/sec even if you are mixing them.</span></div>
<div class="line">    <span class="comment">//         Other actions such as run toggling, jumping, wpn reload also got the 500 millisecs rate-limiting at client-side.</span></div>
<div class="line">    <span class="comment">//         All the mentioned rate-limits are also enforced at server-side, thus storming the server programmatically won&#39;t lead to any benefit.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// AP-99: drop clients who are storming the server with too high rate (maybe programmatically).</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// v0.1.4: attack i.e. left mouse button press also became a continuous operation like strafe, so from now only the press and release generate packets towards server.</span></div>
<div class="line">    <span class="comment">//         So now the more clicks, the more packets: worst-case 5 PKT/sec for 1 rapidly clicking player.</span></div>
<div class="line">    <span class="comment">//         With nPlayerCount number of MsgUserCmdFromClient:</span></div>
<div class="line">    <span class="comment">//         8 * 5 = 40 PKT/s @ 60 FPS total incoming to server (1 will be by the server by injection though),</span></div>
<div class="line">    <span class="comment">//         that is 1 * 5 = 5 PKT/s @ 60 FPS from a single client.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// v0.1.4: mouse/xhair moving-induced player- and weapon-angle update sending is also rate-limited.</span></div>
<div class="line">    <span class="comment">//         Because the same message type is used for updating weapon angle and attacking state, the exact weapon angle will be sent to server at the moment of starting the attack, so</span></div>
<div class="line">    <span class="comment">//         the bullet born on server-side is expected to have the proper same angle.  </span></div>
<div class="line">    <span class="comment">//         However, if too low rate is set and the client is rapidly changing weapon angle during continuous shooting with an automatic weapon like mchgun, some newborn bullets might have</span></div>
<div class="line">    <span class="comment">//         a bit different angle on server-side compared to the client-side angle of the weapon. To avoid this, we cannot set too low rates for this.</span></div>
<div class="line">    <span class="comment">//         Originally I used 200 millisec intervals for player angle and bigger (more than 30 degrees) weapon angle changes, and 300 millisec for smaller changes, which shows noticeable</span></div>
<div class="line">    <span class="comment">//         artifacts of this kind.</span></div>
<div class="line">    <span class="comment">//         So for now I use 100 instead of 200 millisec, and use 200 instead of 300 millisec intervals.</span></div>
<div class="line">    <span class="comment">//         Note that I could also do something like dynamically switching to higher send rate whenever the user is attacking, and switch back to lower when user is not attacking.</span></div>
<div class="line">    <span class="comment">//         But for now I just stick to the fixed higher rates because the number of sent packets is still reasonable I think.</span></div>
<div class="line">    <span class="comment">//         AP-99: introduce unreliable sending of packets so that they are always sent out to server continuously, in that case weapon angle could be sent with higher rate too!</span></div>
<div class="line">    <span class="comment">//         This means max ~16 PKTs, so:</span></div>
<div class="line">    <span class="comment">//         1*8 * 16 = 128 PKT/s @ 60 FPS total incoming to server (1 will be by the server by injection though),</span></div>
<div class="line">    <span class="comment">//         that is 1 * 16 = 16 PKT/s @ 60 FPS from a single client.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="future_plans"></a>
Future Improvement Plans</h1>
<h2><a class="anchor" id="future_plans_server"></a>
Server Future Improvement Plans</h2>
<p>Currently server in every tick invokes serverSendUserUpdates() that sends out MsgUserUpdateFromServer to all players about the state of a player if any state is dirty. <br  />
 Because this is happening frequently, <b>we could use unreliable connection for this instead of reliable</b> to reduce overhead of reliable connection, even though I'm not sure about the amount of the overhead. <br  />
 Note that reliable and unreliable are 2 different ways of sending messages using GNS, and none of them is using TCP. <br  />
 <b>Both use UDP.</b> <br  />
 The difference is that <b>reliable messages are automatically retransmitted in case of loss, can be expected to be received exactly once, and their order is guaranteed to be same on the receiver side as on the sender side</b>. <br  />
 Some info about the <a href="https://github.com/ValveSoftware/GameNetworkingSockets/blob/master/src/steamnetworkingsockets/clientlib/SNP_WIRE_FORMAT.md" target="_blank">message segment differences here</a>. <br  />
 Because loss of such message would NOT be a big problem. But it should be done as QuakeWorld/Counter-Strike does: even if player data is NOT dirty, the state is sent out. <br  />
 This can overcome the inconsistency issues caused by packet loss: if a packet is missing, no problem, the next packet will bring fresher data anyway. <br  />
 However, at this point I'm still not convinced if I should start experimenting with this though. <br  />
 At the same time I'm also thinking that there is no packet loss in small LAN environment.</p>
<p><b>How server code should work without client-side prediction</b>: <br  />
 Remember that with the naive approach, we immediately processed the messages received from clients. <br  />
 We don't do this anymore, since server also has tickrate and we should stick to it: game simulation and input sampling is happening in each tick, not in each frame. <br  />
 So whenever a client input message is received on server-side, instead of processing it immediately, we enqueue it. <br  />
 Server dequeues all received messages at its next tick, and responses will be also sent out at this time in the separate serverSendUserUpdates(). <br  />
 Remember: the lower the value of <b>cl_updaterate</b>, the more we depend on client-side lerp and input-prediction to smooth out player movement experience.</p>
<p>Interesting fact: the original Doom <a href="https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/" target="_blank">used P2P lockstep mechanism multiplayer</a>, which at that time was not good to be played over the Internet. <br  />
 Then Quake introduced the client-server model with the client-side lerp, which was good for LAN, but less good on Internet with bigger distances between machines. <br  />
 So they introduced client-side prediction in QuakeWorld.</p>
<h2><a class="anchor" id="future_plans_client"></a>
Client Future Improvement Plans</h2>
<p>On the internet you can read that: in every tick (instead of every frame), player input is sampled and sent as a message to the server. <br  />
 I already described this earlier why I think this is not good as it introduces noticable delay: <br  />
 with framerate 60 versus tickrate 20, a keypress might be sent to server (1000/20) - (1000/60) = ~33 milliseconds later. <br  />
 And this latency would be on client-side, that would be added to latency between client-server. I think that would be NOT acceptable. <br  />
 Maybe later I will change my mind.</p>
<p>Another improvement would be: we don't even need to send messages in every tick, we can just further enqueue messages over multiple ticks, and send them at lower rate than tickrate, to further reduce required bandwidth. <br  />
 This lower rate is called <b>command rate</b>, rule is: <b>tickrate &gt;= command rate</b>. <br  />
 As optimization, we could send these client messages in 1 single packet to the server, since sending each message in different packet introduces too high overhead. <br  />
 They say that the <a href="https://stackoverflow.com/questions/1098897/what-is-the-largest-safe-udp-packet-size-on-the-internet" target="_blank">"maximum safe UDP payload is 508 bytes"</a>. <br  />
 GNS also uses UDP under the hood. <br  />
 As of June of 2023 (in PRooFPS-dd v0.1.2 Private Beta), size of PgePacket was 268 Bytes, room for application message (MsgApp struct) was 260 Bytes. <br  />
 Size of a MsgUserCmdMove struct was 20 Bytes, which means that by implementing placing multiple messages into a single packet we could send more than 10 such messages in a single PgePacket. <br  />
 Even though I'm not sure what is the size of the whole packet/message sent by GNS, I'm pretty sure it is still below this 508 Bytes when being added to the size of a PgePacket.</p>
<p>Due to the low tickrate (e.g. 50 ms, meaning 20 ticks per second), the <b>player movement can appear choppy and delayed</b>. <br  />
 This is why we need some tricks here:</p><ul>
<li>either client-side lerp (linear interpolation);</li>
<li>and/or client-side prediction.</li>
</ul>
<p>With <b>client-side lerp</b>, the last received player coordinate (from server) is cached, the player object is NOT YET positioned to that coordinate. <br  />
 Instead, the player object is moved between its current position and the cached position using linear interpolation. The object position is updated in every rendered frame. <br  />
 This way the <b>movement of player object will be continuous even though we receive updated positions less frequently. This removes the choppiness but delay will remain.</b> <br  />
 Note that we apply this technique for all player objects at client-side, and also at server-side. <br  />
 We have to be careful though, because <b>this introduces a bit of lag</b>, due to player object position will be always some frames behind the cached server position. <br  />
 So it is better to do the interpolation fast to keep object position close to the cached position i.e. keep interpolation time <b>cl_interp</b> as a small value.</p>
<p>Note that it might be a good idea to cache not only the latest but the 2 latest positions received from server, and set the lerp time to be as long as twice the delay between 2 updates received from server. <br  />
 For example, if tickrate is 20 i.e. delay between updates from server is 50 ms, we can set lerp time cl_interp to 2x50ms, so if 1 update is dropped for any reason, the lerp can still continue as it is not yet finished anyway.</p>
<p>TODO: add debug CVAR that can show the cached/server position on client side of objects so we can see the delay compared to server. <br  />
 I'm expecting the player object to be delayed relative to the debug box with the lerp, but ahead with the client-side prediction!</p>
<p>With <b>client-side prediction</b>, we don't need to use lerp for the current player, because <b>we don't wait for server response for the client's user input</b>. <br  />
 We keep lerp only for other players' objects. <br  />
 This is a fundamentally different approach because we discussed earlier that clients always wait the response from the server. <br  />
 With this approach we move our player object immediately based on local input, and send the usual message to server. <br  />
 We need to introduce a unique message index in the sent message and the response message as well. This index to be used later when processing response from server. Client also saves the sent messages to a queue along with the calculated player object position, because it will need them later when it receives response from server. <br  />
 Server will respond back as usual, and upon receiving the new coordinates, we check if the predicted values are correct: the truth is always what server responds. <br  />
 We can dequeue the stored messages having message index less than or equal to the message index present in server response, and if there is difference in player position in server response compared to the player position in the enqueued message with same index, we align player object position to what server has just responded to us and we replay the remaining stored messages at client-side so that the player object will be correctly positioned based on server's latest confirmed state. <br  />
 Note that obviously we don't need to send the replayed messages again to server, since those commands were already sent to server earlier, we will get response for them too a bit later from the server. <br  />
 This way <b>server remains the only authoritive instance in the network</b>, but we let clients see themselves a bit ahead in time compared to the server, and hopefully there will be only rare occasions when we need to correct the predicted positions at client side. <br  />
 <a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank">"The client sees the game world in present time, but because of lag, the updates it gets from the server are actually the state of the game in the past. By the time the server sent the updated game state, it hadn’t processed all the commands sent by the client."</a> Note that this approach also means that clients also have to simulate physics, otherwise they cannot properly predict new player positions, e.g. they need to do collision check against walls. <br  />
</p>
<h1><a class="anchor" id="cs_1_6_rates_explained"></a>
Counter-Strike 1.6 Rates Explained</h1>
<p>Following CVARs (config variables) are available for tweaking networking in CS 1.6:</p><ul>
<li><b>tickrate</b> - rate at which the server is running simulation, e.g. 20 means 20 ticks per second i.e. in every 50 ms. This value is also used on client side, there this is the rate the client is processing user input.</li>
<li><b>rate</b> - ingress bandwidth of client (client tells this to server). Bytes/sec. Half-Life 1/CS actually has a maximum rate of 20000 Bytes/sec.</li>
<li><b>sv_lan_rate</b> - same as rate but on LAN.</li>
<li><b>cl_updaterate</b> - rate at which the server is sending snapshot updates to the client. It cannot be higher than <b>tickrate</b> and cannot exceed bandwith specified by <b>rate</b>.</li>
<li><b>cl_cmdrate</b> - rate at which client is sending user input packets to the server. Note that although user input is processed at <b>tickrate</b> rate, the command packets are sent out at <b>cl_cmdrate rate</b>, which means that multiple commands might be tied together into a single packet.</li>
<li><b>cl_interp</b> - client-side interpolation period: interpolating entity positions between 2 snapshots so that if there is too big time difference between 2 snapshots it will still look continuous.</li>
<li><b>cl_extrapolate</b> - extrapolation is used if interpolation cannot be done due to too many lost snapshots.</li>
<li><b>cl_predict</b> - turn on/off client input prediction.</li>
<li><b>cl_smooth</b> - turn on/off client-side input prediction error smoothing.</li>
<li><b>sv_showhitboxes</b> - if enabled, clients will draw the hitboxes used on server side. They are expected of ahead of the player by the lerp (linear interpolation) period.</li>
</ul>
<p>Details:</p><ul>
<li><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking">https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking</a></li>
<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=126383209">https://steamcommunity.com/sharedfiles/filedetails/?id=126383209</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 20 2024 01:53:42 for PRooFPS-dd Dev Doc by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
